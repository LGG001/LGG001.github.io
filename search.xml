<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言算法-排序]]></title>
    <url>%2F2018%2F10%2F14%2FC%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C语言算法-排序]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSC802虚拟示波器测评]]></title>
    <url>%2F2018%2F10%2F03%2FOSC802%E8%99%9A%E6%8B%9F%E7%A4%BA%E6%B3%A2%E5%99%A8%E6%B5%8B%E8%AF%84%2F</url>
    <content type="text"><![CDATA[OSC802虚拟示波器测评 环境介绍PC环境：Windows10 64-bit硬件：OSC802 + P2200（200MHz）探头软件：上位机 + 驱动（Win10自带WinUSB驱动，插入自动安装） 上位机下载：下载地址]]></content>
      <categories>
        <category>测评</category>
      </categories>
      <tags>
        <tag>OSC802虚拟示波器测评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-sorted排序应用]]></title>
    <url>%2F2018%2F10%2F02%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-sorted%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python开发入门-sorted排序应用 Python对数据进行排序有许多种方法，本文主要讨论Python的sorted函数（该函数为Python的内建函数），介绍sorted的功能 环境介绍PC环境：Windows10 64bitPython版本：Python3.6（IDLE） sorted介绍sorted用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大。在python的IDLE环境中输入help(sorted)，可以看到一下描述12345678&gt;&gt;&gt; help(sorted)Help on built-in function sorted in module builtins:sorted(iterable, /, *, key=None, reverse=False) Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. 升降排序一般情况下sorted函数将列表按升序进行排序，并返回一个新列表对象，原列表保持不变123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums)[1, 2, 3, 4, 5] 如果要按照降序排列，只需指定参数 reverse=True 即可 123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums, reverse=True)[5, 4, 3, 2, 1] 指定参数key排序按照某个规则排序，则需指定参数 key，key 是一个函数对象，例如字符串构成的列表，我想按照字符串的长度来排序 123&gt;&gt;&gt; chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']&gt;&gt;&gt; sorted(chars, key=len)['a', 'is', 'from', 'test', 'This', 'Andrew', 'string']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python应用-Excel图表制作]]></title>
    <url>%2F2018%2F09%2F29%2FPython%E5%BA%94%E7%94%A8-Excel%E5%9B%BE%E8%A1%A8%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python应用-Excel图表制作 在实际应用过程中会经常使用excel工具来处理一些数据，或者让里面的数据可视化（图标形式），如果是一个两个那么手动就能处理，如果成千上万的那么手动处理的方式就显得很吃力了。针对excel的处理可通过Python来实现，本文介绍如何使用Python来操作excel文件 环境介绍PC环境：WindowsPython版本：Python3.6IDE环境：PyCharm使用第三方库：openpyxl源码下载：http://pf9cmqo3z.bkt.clouddn.com/python_excel.zip 使用PyCharm建立Python工程在桌面新建文件夹：python_excel，双击打开PyCharm，点击Create New Project新建Python工程，选择工程目录文件夹为刚新建的python_excel，使用新的虚拟环境，选择Python解释器为Python3.6，如下图 工程建立完成后，在工程目录下新建文件：excel.py 使用PyCharm安装openpyxl库在PyCharm中安装openpyxl库。点击菜单栏File–&gt;Settings选择Project:python_excel下的Project Interpreter，然后点击右边的小加号，在弹出的窗口中搜索需要安装的库，然后点击安装 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from openpyxl import Workbookfrom openpyxl.chart import BarChart, Series, Referencedef excel_make(): wb = Workbook(write_only=True) ws = wb.create_sheet() rows = [ ('Number', 'Batch 1', 'Batch 2'), (2, 10, 30), (3, 40, 60), (4, 50, 70), (5, 20, 10), (6, 10, 40), (7, 50, 30), ] for row in rows: ws.append(row) chart1 = BarChart() chart1.type = "col" chart1.style = 10 chart1.title = "Bar Chart" chart1.y_axis.title = 'Test number' chart1.x_axis.title = 'Sample length (mm)' data = Reference(ws, min_col=2, min_row=1, max_row=7, max_col=3) cats = Reference(ws, min_col=1, min_row=2, max_row=7) chart1.add_data(data, titles_from_data=True) chart1.set_categories(cats) chart1.shape = 4 ws.add_chart(chart1, "A10") from copy import deepcopy chart2 = deepcopy(chart1) chart2.style = 11 chart2.type = "bar" chart2.title = "Horizontal Bar Chart" ws.add_chart(chart2, "G10") chart3 = deepcopy(chart1) chart3.type = "col" chart3.style = 12 chart3.grouping = "stacked" chart3.overlap = 100 chart3.title = 'Stacked Chart' ws.add_chart(chart3, "A27") chart4 = deepcopy(chart1) chart4.type = "bar" chart4.style = 13 chart4.grouping = "percentStacked" chart4.overlap = 100 chart4.title = 'Percent Stacked Chart' ws.add_chart(chart4, "G27") wb.save("bar.xlsx") if __name__ == '__main__': excel_make() 实现效果运行代码，可以看到生成一个bar.xlsx文件，打开后可以看到根据数据生成的四种不同图标 openpyxl使用参考：https://openpyxl.readthedocs.io/en/stable/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-安装第三方库]]></title>
    <url>%2F2018%2F09%2F28%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Python开发入门-安装第三方库 环境介绍PC环境：Windows10 64bitPython版本：Python3.6或Python2.7IDE环境：PyCharm pip安装大部分的库可以打开命令行，使用命令:1pip install xxx 如：安装flask库 下载压缩包安装在https://pypi.org/中找到要安装的库，把对应的压缩包下载下来。 解压下载的安装包，解压后通常会看见一个setup的文件，然后打开命令行，进入该文件夹，使用命令：1python setup.py install 下载.whl文件安装下载地址： https://www.lfd.uci.edu/~gohlke/pythonlibs/# 在下载地址把想要安装的库对应的.whl文件下载下来(如pykinsol库：pykinsol-0.1.2-cp36-cp36m-win_amd64，注意的是cp36对应python3.6版本，amd64对应Windows-64bit)，然后打开命令行，进入该文件所在的文件夹，使用命令：1pip install pykinsol-0.1.2-cp36-cp36m-win_amd64.whl]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python应用-爬取京东书籍信息]]></title>
    <url>%2F2018%2F09%2F25%2FPython%E5%BA%94%E7%94%A8-%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Python应用-爬取京东书籍信息 说到Python的应用，听到比较多的市爬虫，爬虫也是Python入门最好的练手项目。本文主要讲解xpath的用法，并使用xpath来分析和抓取爬取京东书籍的相关信息。关于书籍有一个基本的概念：国际标准书号（简称ISBN），每一本书出版都带有一个唯一的ISBN，本文也是通过ISBN来找到对应数据的信息 环境介绍PC环境：WindowsPython版本：Python3.6IDE环境：PyCharm使用第三方库：lxml、requests源码下载：http://pf9cmqo3z.bkt.clouddn.com/python_spiderJD.zip 使用PyCharm建立Python工程在桌面新建文件夹：python_spiderJD，双击打开PyCharm，点击Create New Project新建Python工程，选择工程目录文件夹为刚新建的python_spiderJD，使用新的虚拟环境，选择Python解释器为Python3.6，如下图 工程建立完成后，在工程目录下新建文件：spiderJD.py 使用PyCharm安装相关第三方库在PyCharm中安装lxml和requests库。点击菜单栏File–&gt;Settings选择Project:python_spiderJD下的Project Interpreter，然后点击右边的小加号，在弹出的窗口中搜索需要安装的库，然后点击安装 安装好lxml和requests库后，可以看到该环境下多出了一下库（注：如提示安装失败，可能是由于pip的版本问题导致，可以将pip的版本降级为pip9以下版本或修改相关脚本文件） 代码实现爬取京东指定ISBN号书籍信息代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom lxml import html# 在京东商城通过ISBN来查找对应书籍信息def spider(isbn): # 获取URL url = 'https://search.jd.com/Search?keyword=&#123;0&#125;'.format(isbn) # 获取HTML文档，并将编码改为'utf-8' resp = requests.get(url) print(resp.encoding) resp.encoding = 'utf-8' html_doc = resp.text # 获取xpath对象 selector = html.fromstring(html_doc) # 找到列表的集合 ul_list = selector.xpath('//div[@id = "J_goodsList"]/ul/li') print(len(ul_list)) # 解析对应的内容、标题、价格、连接并打印 for li in ul_list: # 标题 title = li.xpath('div/div[@class = "p-name"]/a/@title') print(title[0]) # 购买连接 link = li.xpath('div/div[@class = "p-name"]/a/@href') print(link[0]) # 价格 price = li.xpath('div/div[@class="p-price"]/strong/i/text()') print(price[0]) # 店铺 store = li.xpath('div//a[@class="curr-shop"]/@title') print(store)if __name__ == '__main__': isbn = input('请输入ISBN') spider(isbn) 代码分析 首先导入requests库和lxml的html方法 定义函数实现获取京东网指定ISBN书籍信息 根据获取URL页面内容 把页面内容的编码方式改为utf-8 将页面内容转换为xpath对象 使用xpath解析页面内容，找出有用信息并打印 实现效果运行代码，输入ISBN号（以书籍 Python编程快速上手 让繁琐工作自动化 ISBN：9787115422699 为例），点击回车，如下 HTML页面分析技巧打开京东，搜索框中输入ISBN：9787115422699，点击搜索，然后按F12查看网页源码，点击左上角的小箭头工具，然后选择书籍的区域，这时会自动定位到源码中的位置]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-开发环境搭建]]></title>
    <url>%2F2018%2F09%2F17%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Python开发入门-开发环境搭建 人生苦短，我用Python。Python是一门非常容易入门的语言，同时也是一门高效的语言，在开始学习之前，需要搭建Python的开发环境。本文介绍Python3.6 + Python2.7的环境安装，同时也介绍相关的Python工具安装。Python主要有两个版本：Python3和Python2，这两个版本是不兼容的，Python2会在2020年停止维护，但是目前很多Python相关的库只支持Python2，而且有很多脚本工具也是使用Python2环境，所以在搭建Python的开发环境使用Python3和Python2兼容的方式安装 环境介绍PC环境：Windows10 64bitPython版本：Python3.6 + Python2.7IDE环境：PyCharm其他（可选）：Sublime Txt3 工具下载下面给出各工具的下载地址，根据不同的环境选择相对于的安装包进行安装： Python3.6 + Python2.7：https://www.python.org/downloads/ PyCharm：http://www.jetbrains.com/pycharm/download/#section=windows Sublime Txt3：https://www.sublimetext.com/3 工具安装Python3.6 + Python2.7安装下载Python3.6（目前Python3.6版本比较稳定）的对应安装包，双击安装（安装目录设为C:\Python36） 下载Python2.7的对应安装包，双击安装（安装目录设为C:\Python27） 安装完成后，需要添加环境变量，通过修改环境变量达到Python3和Python2切换使用。点击我的电脑–&gt;右键属性–&gt;高级系统设置–&gt;环境变量 在系统变量中新建一个环境变量，变量名：PY_HOME；值：C:\Python36（设置Python3为有效） 选择系统变量的Path，在他的值中添加%PY_HOME%\;%PY_HOME%\Scripts\; 点击确定完成设置，目前设置Python3为有效（如果要设置Python2有效，则把环境变量PY_HOME的值改为Python27即可），打开CMD命令行工具，输入python，则会进入python环境并打印Python3的版本号等信息 输入exit()退出python环境，输入pip -V，则会打印pip相关信息，python的环境到此安装完毕 PyCharm安装进入PyCharm官方，会有两个版本提供下载：专业版（收费）；社区版（免费开源），选择社区版下载安装即可，安装过程一路点击Next即可安装完成 Sublime Txt3安装Sublime Txt3是我个人非常喜欢的一款代码编辑工具，功能非常强大（几乎满足程序员的所有要求），下载安装也是很简单，到官网上下载，然后双击安装，一路Next即可。需要注意的是Sublime Txt3是收费的软件，但是网上有很多破解的教程，不过个人建议支持正版]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-Error:micro_ecc_lib_nrf52.lib:No such file or directory]]></title>
    <url>%2F2018%2F09%2F11%2FnRF52832-Error-micro-ecc-lib-nrf52-lib-No-such-file-or-directory%2F</url>
    <content type="text"><![CDATA[micro_ecc_lib_nrf52.lib错误解决 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 错误产生及原因在打开nRF5 SDK v15.1.0中的蓝牙外设例程（如心率例程：nRF5_SDK_15.1.0_a8c0c4d\examples\ble_peripheral\ble_app_hrs\pca10040\s132\arm5_no_packs）编译过程中发现一个错误123456linking....\_build\nrf52832_xxaa.axf: error: L6002U: Could not open file ..\..\..\..\..\..\external\micro-ecc\nrf52hf_keil\armgcc\micro_ecc_lib_nrf52.lib: No such file or directoryFinished: 0 information, 0 warning, 0 error and 1 fatal error messages.".\_build\nrf52832_xxaa.axf" - 1 Error(s), 0 Warning(s).Target not created.Build Time Elapsed: 00:00:33 从错误的提示来看，是在nRF5_SDK_15.1.0_a8c0c4d\external\micro-ecc\nrf52hf_keil\armgcc目录下缺少了micro_ecc_lib_nrf52.lib文件，打开该目录发现确实是缺少该文件 错误解决方法方法1直接copy一个micro_ecc_lib_nrf52.lib文件到该目录下，下载连接：micro_ecc_lib_nrf52.lib 方法2参考官方的解决方法，生成一个micro_ecc_lib_nrf52.lib文件 官方文档：http://infocenter.nordicsemi.com/index.jsp 解决位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Libraries &gt; Cryptography library - nrf_crypto &gt; nrf_crypto backend modules &gt; micro_ecc backend]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用-PPI使用]]></title>
    <url>%2F2018%2F09%2F09%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-PPI%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-PPI使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的pwm_library例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\ppi\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs PPI使用配置PPI配置步骤如下： 实例化PPI的通道 初始化PPI外设 为PPI通道申请内存，指定事件触发相关任务 使能PPI PPI相关参数说明： nRF52832的PPI通道由20个，在nrf52832_peripherals.h文件中定义 使用SoftDevice时，timer0不能使用 官方源码分析官方源码中PWM应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#define PPI_EXAMPLE_TIMERS_PHASE_SHIFT_DELAY (10) // 1s = 10 * 100ms (定时器1和定时器2的启动时间间隔)#define PPI_EXAMPLE_TIMER0_INTERVAL (100) // Timer0的定时时间 = 100ms#define PPI_EXAMPLE_TIMER1_INTERVAL (2000) // Timer1的定时时间 = 2s#define PPI_EXAMPLE_TIMER2_INTERVAL (2000) // Timer2的定时时间 = 2sstatic const nrf_drv_timer_t m_timer0 = NRF_DRV_TIMER_INSTANCE(0); //实例化Timer0static const nrf_drv_timer_t m_timer1 = NRF_DRV_TIMER_INSTANCE(1); //实例化Timer1static const nrf_drv_timer_t m_timer2 = NRF_DRV_TIMER_INSTANCE(2); //实例化Timer1static nrf_ppi_channel_t m_ppi_channel1; //PPI实例化channel1static nrf_ppi_channel_t m_ppi_channel2; //PPI实例化channel2static volatile uint32_t m_counter; //定义变量，技术Timer0的中断次数//Timer0的回调函数static void timer0_event_handler(nrf_timer_event_t event_type, void * p_context)&#123; ++m_counter;&#125;/* Timer1和Timer2的回调函数，由于Timer1和Timer2只用于PPI，所以没有使用 */static void empty_timer_handler(nrf_timer_event_t event_type, void * p_context)&#123;&#125;/** @brief PPI初始化函数.*/static void ppi_init(void)&#123; uint32_t err_code = NRF_SUCCESS; err_code = nrf_drv_ppi_init(); //PPI初始化 APP_ERROR_CHECK(err_code); //PPI的channel1初始化，通过Timer1的NRF_TIMER_EVENT_COMPARE0时间来使Timer0停止运行 err_code = nrf_drv_ppi_channel_alloc(&amp;m_ppi_channel1); //PPI的channel1申请内存 APP_ERROR_CHECK(err_code); //PPI的channel1分配任务，通过Timer1的NRF_TIMER_EVENT_COMPARE0时间来使Timer0停止运行 err_code = nrf_drv_ppi_channel_assign(m_ppi_channel1, nrf_drv_timer_event_address_get(&amp;m_timer1, NRF_TIMER_EVENT_COMPARE0), nrf_drv_timer_task_address_get(&amp;m_timer0, NRF_TIMER_TASK_STOP)); APP_ERROR_CHECK(err_code); //PPI的channel2初始化，通过Timer2的NRF_TIMER_EVENT_COMPARE0时间来使Timer0恢复运行 err_code = nrf_drv_ppi_channel_alloc(&amp;m_ppi_channel2); //PPI的channel2申请内存 APP_ERROR_CHECK(err_code); //PPI的channel2分配任务，通过Timer2的NRF_TIMER_EVENT_COMPARE0时间来使Timer0恢复运行 err_code = nrf_drv_ppi_channel_assign(m_ppi_channel2, nrf_drv_timer_event_address_get(&amp;m_timer2, NRF_TIMER_EVENT_COMPARE0), nrf_drv_timer_task_address_get(&amp;m_timer0, NRF_TIMER_TASK_START)); APP_ERROR_CHECK(err_code); // 使能PPI channels1、channels2 err_code = nrf_drv_ppi_channel_enable(m_ppi_channel1); APP_ERROR_CHECK(err_code); err_code = nrf_drv_ppi_channel_enable(m_ppi_channel2); APP_ERROR_CHECK(err_code);&#125;/** @brief Timer 0 初始化函数. * @details 实现功能：100ms触发一次NRF_TIMER_CC_CHANNEL0事件 */static void timer0_init(void)&#123; nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer0, &amp;timer_cfg, timer0_event_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer0, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer0, PPI_EXAMPLE_TIMER0_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true);&#125;/** @brief Timer 1 初始化函数. * @details 实现功能：2s触发一次NRF_TIMER_CC_CHANNEL0事件，通过PPI使Timer0停止运行 */static void timer1_init(void)&#123; nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer1, &amp;timer_cfg, empty_timer_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer1, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer1, PPI_EXAMPLE_TIMER1_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);&#125;/** @brief Timer 2 初始化函数. * @details 实现功能：2s触发一次NRF_TIMER_CC_CHANNEL0事件，通过PPI使Timer0恢复运行 */static void timer2_init(void)&#123; // Check TIMER2 configuration for details. nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer2, &amp;timer_cfg, empty_timer_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer2, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer2, PPI_EXAMPLE_TIMER2_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);&#125;/** * @brief Function for application main entry. */int main(void)&#123; uint32_t old_val = 0; uint32_t err_code; err_code = NRF_LOG_INIT(NULL); APP_ERROR_CHECK(err_code); NRF_LOG_DEFAULT_BACKENDS_INIT(); ppi_init(); //PPI初始化 timer0_init(); // Timer 0初始化 timer1_init(); // Timer 1初始化 timer2_init(); // Timer 2初始化 NRF_LOG_INFO("PPI example started."); //打印信息 nrf_drv_timer_enable(&amp;m_timer0); //使能Timer0 nrf_delay_us(5); //延迟5us，保障Timer0能在PPI触发前执行中断 nrf_drv_timer_enable(&amp;m_timer1); //使能Timer1 m_counter = (uint32_t)-PPI_EXAMPLE_TIMERS_PHASE_SHIFT_DELAY; while (m_counter != 0) //这里目的使等到10s，m_counter = -10，通过Timer0每100ms加一 &#123; // just wait &#125; nrf_drv_timer_enable(&amp;m_timer2); //使能Timer2，奇数秒Timer1触发停止Timer0，偶数秒Timer2触发运行Timer0 while (true) &#123; uint32_t counter = m_counter; if (old_val != counter) //Timer0使能时，每100ms打印一次counter值 &#123; old_val = counter; NRF_LOG_INFO("Current count: %u", counter); NRF_LOG_FLUSH(); &#125; &#125;&#125; 官方的例程实现过程以及效果： 实例化Timer0（100ms）、Timer1（2s）、Timer2（2s） 实例化PPI的channel1、channel2 实现Timer0回调函数，Timer1和Timer2回调函数（没有实际应用） 初始化PPI 配置PPI的channel1用于Timer2事件触发停止Timer0 配置PPI的channel1用于Timer2事件触发运行Timer0 使能PPI的channel1、channel2 初始化Timer Timer0每100ms触发NRF_TIMER_CC_CHANNEL0事件，m_counter变量加1 Timer1每2s触发NRF_TIMER_CC_CHANNEL0事件 Timer2每2s触发NRF_TIMER_CC_CHANNEL0事件 主函数实现奇数秒Timer1触发停止Timer0，偶数秒Timer2触发运行Timer0，Timer0使能时，每100ms打印一次counter值 实现效果：串口一秒打印十次counter值，然后停止一秒，依次循环串口配置： 波特率：115200 8位数据位 1位停止位 无奇偶校验 无流控 使用串口助手查看的效果如下： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; PPI Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; PPI 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:PWM使用]]></title>
    <url>%2F2018%2F09%2F09%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-PWM%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-PWM使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的pwm_library例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\pwm_library\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs PWM使用配置PWM配置步骤如下： 使用定时器实例化PWM 实现回调函数 PWM配置，可选择同时配置1个通道或两个通道以及其输出引脚，其他配置可使用独立函数进行配置 初始化PWM配置 使能PWM PWM相关参数说明： 定时器一共有5个：timer0~4，所以最多实例5个PWM 使用SoftDevice时，timer0不能使用 每个PWM实例最多可配置2个通道 官方源码分析官方源码中PWM应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243APP_PWM_INSTANCE(PWM1,1); // 使用定时器1实例化PWM，命名为PWM1static volatile bool ready_flag; // PWM指示标志位void pwm_ready_callback(uint32_t pwm_id) // PWM回调函数&#123; ready_flag = true;&#125;int main(void)&#123; ret_code_t err_code; /* 2-channel PWM配置, 频率200Hz, 输出在P17、P18引脚. */ app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, BSP_LED_0, BSP_LED_1); /* 切换第二通道的极性. */ pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH; /* 初始化和使能 PWM. */ err_code = app_pwm_init(&amp;PWM1,&amp;pwm1_cfg,pwm_ready_callback); APP_ERROR_CHECK(err_code); app_pwm_enable(&amp;PWM1); uint32_t value; while (true) &#123; for (uint8_t i = 0; i &lt; 40; ++i) &#123; value = (i &lt; 20) ? (i * 5) : (100 - (i - 20) * 5); ready_flag = false; /* 设置通道0的占空比（1~100），并等到设置完成 */ while (app_pwm_channel_duty_set(&amp;PWM1, 0, value) == NRF_ERROR_BUSY); /* 等待回调函数处理，然后设置通道1的占空比 */ while (!ready_flag); APP_ERROR_CHECK(app_pwm_channel_duty_set(&amp;PWM1, 1, value)); nrf_delay_ms(25); //每25ms改变一次 &#125; &#125;&#125; 官方的例程实现过程以及效果： 通过定时器1来实例化PWM1 实现PWM1的回调函数 在主函数中配置PWM1的同个通道：周期200Hz，使用P17、P18引脚 单独配置通道1的输出极性搞（通道0输出极性默认低） 初始化和使能PWM1 每25ms设置一次通道0、1的占空比(两个通道占空比一样，极性相反) 实现效果：LED1（P17）由亮变暗和LED2（P18）由暗变亮 注：占空比的设置必须在PWM使能后 使用示波器检测P17、P18引脚的效果如下： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; PWM Library Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; SDK common libraries &gt; Pulse-width modulation (PWM) 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:Timer使用]]></title>
    <url>%2F2018%2F09%2F06%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-Timer%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-Timer使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的timer例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\timer\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs Timer使用配置Timer配置步骤如下： 实例化定时器，获取分配的实例ID 实现回调函数 定时器配置，一般使用默认配置，其他配置可使用独立函数进行配置 获取设定时间所需的ticks数 设置定时器通道的拓展比较模式 使能定时器实例 Timer相关参数说明： 定时器一共有5个：timer0~4，所以最多实例5个定时器 使用SoftDevice时，timer0不能使用 每个定时器最多拥有6个捕获比较通道NRF_TIMER_CC_CHANNEL0~5 官方源码分析官方源码中timer应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(0); //实例化timer0，获取分配ID：TIMER_LED/** * @brief 定时器事件处理函数（回调函数） */void timer_led_event_handler(nrf_timer_event_t event_type, void* p_context)&#123; static uint32_t i; uint32_t led_to_invert = ((i++) % LEDS_NUMBER); //LEDS_NUMBER = 4，该语句实现i由0~3依次循环 switch (event_type) //判断事件类型 &#123; case NRF_TIMER_EVENT_COMPARE0: //timer0的COMPARE0事件 bsp_board_led_invert(led_to_invert); //对LED[i]状态进行翻转 break; default: //其他事件不处理 //Do nothing. break; &#125;&#125;/** * @brief Function for main application entry. */int main(void)&#123; uint32_t time_ms = 500; //定时时间500ms uint32_t time_ticks; uint32_t err_code = NRF_SUCCESS; bsp_board_init(BSP_INIT_LEDS); //初始化LED1~LED4 nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; //定时器配置，使用默认配置，默认参数在nrf_timer.h中定义 err_code = nrf_drv_timer_init(&amp;TIMER_LED, &amp;timer_cfg, timer_led_event_handler); //定时器初始化 APP_ERROR_CHECK(err_code); time_ticks = nrf_drv_timer_ms_to_ticks(&amp;TIMER_LED, time_ms); //获取500ms所需的ticks数 nrf_drv_timer_extended_compare( //配置timer0的捕获比较通道0的拓展比较模式，使能该通道中断 &amp;TIMER_LED, NRF_TIMER_CC_CHANNEL0, time_ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true); nrf_drv_timer_enable(&amp;TIMER_LED); //使能定时器 while (1) &#123; __WFI(); //进入低功耗模式 &#125;&#125; 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; Timer Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; TIMER 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:GPIO输出]]></title>
    <url>%2F2018%2F09%2F04%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-GPIO%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[nRF52832-GPIO输出 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的blinky例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\blinky\pca10040\s132\arm5_no_packs目录下。注：pca10040代表nRF52832例程，s132代表基于协议栈的工程，ARM-MDK5选择arm5_no_packs GPIO输出配置打开工程并打开main.c文件，可以看到mian函数内容如下：123456789101112131415int main(void)&#123; /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) &#123; for (int i = 0; i &lt; LEDS_NUMBER; i++) &#123; bsp_board_led_invert(i); nrf_delay_ms(500); &#125; &#125;&#125; 该例程是基于pca10040（nRF52832）开发板的LED例程，实现LED1~LED4依次闪烁的功能，下面根据LED的GPIO配置来配置P25和P26引脚输出高低电平，在main.c中添加自定义函数，如下：1234567891011121314/** * @函数名 Custom_Init * @功 能 用户自定义GPIO口初始化 * @参 数 无 * @返回值 无 */void Custom_Init(void)&#123; nrf_gpio_cfg_output(25); //初始化P25引脚，配置为输出模式 nrf_gpio_cfg_output(26); //初始化P26引脚，配置为输出模式 nrf_gpio_pin_write(25, 0); //P25引脚输出低电平 nrf_gpio_pin_write(26, 0); //P26引脚输出低电平&#125; 把该函数在main函数中初始化，然后在主函数循环中翻转P25和P26引脚状态，main函数如下：1234567891011121314151617int main(void)&#123; /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) &#123; for (int i = 0; i &lt; LEDS_NUMBER; i++) &#123; bsp_board_led_invert(i); nrf_gpio_pin_toggle(25); //翻转P25引脚状态 nrf_gpio_pin_toggle(26); //翻转P26引脚状态 nrf_delay_ms(500); &#125; &#125;&#125; 使用示波器检测P25和P26引脚状态，如下图： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; Blinky Example GPIO相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; GPIO 代码烧录 擦除FLASH 烧写SoftDevice 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-程序下载]]></title>
    <url>%2F2018%2F08%2F29%2FnRF52832-%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[nRF52832程序下载 nRF52832程序下载可以分为两种： 基本外设使用例程，类似单片机的应用例程 基于SoftDevice的例程 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） nRF5283基本外设例程下载基本外设例程位于目录：examples\peripheral\，以该目录下的blinky例程为例，打开blinky\pca10040\blank\arm5_no_packs的MDK工程注：pca10040是官方的nRF52832开发板，IDE环境是ARM-MDK5对应arm5_no_packs中的工程 nRF52832的基本外设例程下载流程分两步： 擦除FLASH（只需要操作一次） 下载应用程序 具体实现如下： 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：基本外设使用的Programming Algorithm是nRF52xxx SoftDevice Erase和nRF52xxx_UICR） 点击菜单栏Flash–&gt;Erase擦除FLASH，点击编译程序没有错误，然后点击Flash–&gt;Download下载程序 SoftDevice例程下载基本外设例程位于目录：examples\peripheral\，以该目录下的blinky例程为例，打开blinky\pca10040\s132\arm5_no_packs的MDK工程注：pca10040是官方的nRF52832开发板，s132是针对nRF52832的SoftDevice，IDE环境是ARM-MDK5对应arm5_no_packs中的工程 nRF52832的基本外设例程下载流程分三步： 擦除FLASH（只需要操作一次） 下载SoftDevice 下载应用程序 在菜单栏切换目标工程为flash_s132_nrf52_6.1.0_softdevice，该工程是softdevice工程，不需要编译 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：SoftDevice使用的Programming Algorithm是nRF52xxx和nRF52xxx_UICR） 点击菜单栏Flash–&gt;Erase擦除FLASH，然后点击Flash–&gt;Download下载SoftDevice 在菜单栏切换目标工程为nrf52832_xxaa，该工程是基于softdevice的应用工程 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：SoftDevice使用的Programming Algorithm是nRF52xxx和nRF52xxx_UICR） 点击编译，然后点击Flash–&gt;Download下载应用程序 下载完成后重启一次，可以看到程序效果：LED1~LED4逐次亮–&gt;灭 基本应用程序与基于SoftDevice应用程序的区别基本应用程序与基于SoftDevice应用程序的区别在于ROM、RAM的分配不一样 基本应用程序的ROM、RAM的分配比较简单，直接是RAM大小和FLASH大小，如下图： 基于SoftDevice应用程序的FLASH和RAM分配比较复杂，因为SoftDevice就占用了一定的FLASH和RAM，应用程序根据剩下的FLASH和RAM空间进行分配定义，根据需求还需要添加Bootloader区域等。本文中的基于SoftDevice应用程序的FLASH和RAM分配如下图：]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-开发环境]]></title>
    <url>%2F2018%2F08%2F29%2FnRF52832-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[开发环境搭建开发环境基于Windows10-64位平台 开发工具下载使用的软件和工具下载地址：nRF52832资源下载 软件开发包（SDK）下载：点击下载 ARM-MDK集成开发环境下载：点击下载 nRF5x的MDK支持包下载：点击下载 ARM.CMSIS.5.4.0.pack下载：点击下载 nRFgo Studio-Win64下载（nRF5x程序下载工具W10-64位）：点击下载 开发工具安装SDK是以压缩包形式打包的，里面包含各个外设的例程、协议栈、蓝牙通讯的Demo等等，下载后解压就可以直接使用 ARM-MDK开发环境安装： 下载并安装ARM-MDK，安装过程一路点击Next即可，建议保持默认路径 安装nRF5x的MDK支持包，双击安装，会自动识别ARM-MDK的安装路径 安装ARM.CMSIS.5.4.0.pack，双击安装，会自动识别ARM-MDK的安装路径 nRFgo Studio安装，该安装过程比较简单，一路保持默认，安装类型选择（Typical）,点击Next即可]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32F103 IAP设计与应用（官方）]]></title>
    <url>%2F2018%2F08%2F15%2FSTM32F103-IAP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[大部分MCU系统会具备下面三种编程方式： IAP（In Application Programming）在应用编程 ISP（In System Programing）在系统编程 ICP（In Circuit Programing）在电路编程 IAP是用户自己的程序在运行过程中对User Flash的部分区域进行重新烧写，产品发布后可以方便地通过预留的通信端口对产品中的固件程序进行更新升级。实现IAP有两个很重要的前提： 单片机程序能对自身内部User Flash进行擦写 单片机要有能够与外部进行通讯，如使用USART、IIC、SPI等 在实现IAP功能时，通常要设计两个程序：IAP程序、APP（应用）程序。IAP程序的功能就是作为Bootloader的角色，通过某种通讯协议（如USART）来接收APP程序并将其烧录到指定的User Flash中（注：IAP与APP程序在同一个FLASH中的不同地址上），然后跳转到APP中执行程序。ST官方提供STM32F10x的IAP相关资料，这里针对官方的STM32F10x的IAP资料进行应用，内容分为以下部分： STM32程序运行过程分析 STM32F10x IAP例程介绍 STM32F10x IAP例程测试 STM32程序运行过程分析想要设计STM32的IAP程序，必须先了解STM32的运行过程，下面以STM32F103的MCU为例介绍它的正常启动运行流程与加入IAP后的程序运行流程。 STM32正常启动流程 STM32上电后会从0x08000004处出去复位中断向量的地址，并跳转执行复位中断服务程序，如① 复位中断程序执行完后就会跳转到main函数中，如② main函数一般为死循环，当收到中断请求后STM32会强制把PC指向中断向量表，如③ 这时会查询中断向量表，根据中断源跳转到相应的中断服务程序中执行，如④ 执行完中断函数后再重新返回main函数中继续执行，如⑤ STM32加入IAP启动流程 STM32上电后会从0x08000004处出去复位中断向量的地址，并跳转执行复位中断服务程序，如① 执行完复位中断服务程序后进入到IAP的main函数中，将新的APP代码烧写到指定的User Flash中，然后跳转到APP中执行程序，如② 在APP中跳转到指定新的向量表，取出复位中断向量地址，并跳转执行新的复位中断服务程序，然后跳转至APP的main函数，如③ 这时FLASH中存在两个向量表，当有中断请求到来时，PC指针仍然会指向地址0x08000004中断向量表，如④ 查询中断向量表，根据中断来源跳转到新（APP）的中断服务程序中执行，如⑤ 执行完中断函数后再重新返回main函数中继续执行，如⑥注：灰色部分为APP代码 IAP例程介绍ST官方提供STM32F10x IAP资源包和一份应用笔记： STM32F10x IAP例程包，下载地址 :point_right: ST官网 STM32F10x IAP应用笔记，下载地址 :point_right: ST官网 IAP相关文件介绍把ST官方的STM32F10x IAP例程包下载并解压，在STM32F10x_AN2557_FW_V3.3.0\Project\IAP目录下有EWARM、HiTOP、MDK-ARM、RIDE、TrueSTUDIO的工程目录，以常用的MDK-ARM为例打开工程，根据目标MCU平台选择工程Target，如MCU平台为STM32F103C8T6（中容量产品），则工程Target选择STM3210B-EVAL，然后编译，IAP主要的代码在工程目录的User Groups下 User Groups下包含的IAP驱动相关的源文件和描述如下： main.c：初始化串口，然后从common.c文件中执行主菜单 common.c：内容显示函数和主菜单程序 ymodem.c和download.c：用于接收超级终端发送过来的数据（采用ymodem协议）并下载到STM32F10x内部RAM中 upload.c：把内部FLASH中的APP代码通过ymodem协议进行上传 整个IAP程序的运行框架如下图： IAP程序运行过程：判断用户按键是否按下（STM3210B-EVAL使用的是PB9，判断PB9是否为低电平），没有按下（PB9为高电平）就直接跳转到用户APP程序执行；如按下，初始化串口1，（连接到超级终端，超级终端）显示IAP菜单，菜单有：1-下载，2-上传，3-跳转（如检测到FLASH被写保护，就会有4-解除写保护）。 键盘输入1：提示下载APP程序文件，通过超级终端的ymodem协议把APP程序的二进制文件传输下载到指定的User FLASH中，如果出现错误则会在超级终端中显示出来，传输下载完成后会重新返回显示IAP主菜单 键盘输入2：提示把FLASH中APP程序通过ymodem协议在超级终端上传，如果出现错误则会在超级终端中显示出来 键盘输入3：跳转到APP程序运行 键盘输入4：解除FLASH写保护（该操作在系统检测到FLASH处于写保护才会显示到超级终端上） IAP例程使用概要IAP驱动程序也是需要下载到FLASH里运行的，IAP程序占用FLASH大小约为12KByte，在不同密度的产品占用FLASH的页数不一样（低、中密度为1KByte字节每页，超高、高密度为2KByte字节每页） 在低、中密度产品中，IAP程序占用FLASH的页0~页11 在超高、高密度产品中，IAP程序占用FLASH的页0~页5 IAP例程还需要一个支持ymodem协议的PC上位机（超级终端），使用STM32的串口连接PC，通过上位机来进行程序的上传和下载，这里使用的上位机软件是：SecureCRT8.3（安装和使用请参考百度） 打开STM32F10x_AN2557_FW_V3.3.0\Project\IAP目录下的MDK-ARM工程，选择Target为STM3210B-EVAL，编译并下载到测试目标板中（测试目标板MCU型号为STM32F103C8T6），通过串口连接测试目标板与PC，打开SecureCRT8.3建立基于串口通讯的快速连接（波特率：115200，数据位：8位，无奇偶校验，停止位：1位，无流控），然后把PB9引脚接低电平，复位测试目标板，可以看到上位机显示 注：程序检测到FLASH没有处于写保护状态时，不会显示FLASH擦除选项 下载APP例程文件在下载APP例程文件前，需要知道IAP程序中设置的APP程序FLASH地址，该地址位于工程的common.h文件下1#define ApplicationAddress 0x8003000 APP程序下载的FLASH起始地址为0x8003000。打开STM32F10x_AN2557_FW_V3.3.0\Project\IAP\binary_template目录下的MDK-ARM工程，选择Target为STM3210B-EVAL，该工程为官方提供的APP例程，打开工程的Options窗口，在Target栏下做如下修改（STM32F103C8T6的FLASH大小为64KB，APP例程的FLASH起始地址设为0x08003000，大小为：64KB-IAP使用的12KB = 52KB = 0xD000） 在User栏下，After Build/Rebuild选项下勾选Run #1，然后在对于的右侧填入D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe --bin -o ./STM3210B-EVAL/@L.bin ./STM3210B-EVAL/@L.axf，该语句的作用是在工程下的STM3210B-EVAL目录下生成STM3210B-EVAL.bin和STM3210B-EVAL.axf文件（如KEIL安装目录不一样，则需要修改D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe） 编译之后就会生成STM3210B-EVAL.bin，该APP例程的效果是4个LED闪烁，LED的IO口定义在stm3210b_eval.h文件下，可根据实际硬件LED连接来修改。 生成.bin文件后，回到上位机界面，然后键盘输入数字：1，此时上位机提示等待接收APP程序文件，在上位机菜单栏点击Transfer–&gt;Send Ymodem…，选择生成的APP程序文件STM3210B-EVAL.bin，然后点击Add，最后点击OK，发送成功后会显示发送的文件文件名和大小，然后再次返回IAP注菜单 注：发送超时会自动返回IAP主菜单 最后键盘输入数字：3，程序跳转到APP运行，可以看到LED闪烁。]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32-IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAPLink设计与应用]]></title>
    <url>%2F2018%2F08%2F12%2FDAPLink%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[DAPLink是ARM官方的一款开源的调试仿真器，之前叫CMSIS-DAP。DAPLink的软件和硬件都在Github上开源： DAPLink软件地址： Github DAPLink硬件地址： Github DAPLink目前源码固件主要使用在LPC11U35以及MK20DX128VFM5的硬件上，并在Github上开源，成熟的DAPLink硬件方案有三个： DIPDAP（主芯片：LCP11U35FHI33/501） STDAP（主芯片：STM32F103CBT6） SWDAP（主芯片：LCP11U35FHI33/501） DAPLink可以对ARM Cortex内核（如 Cortex M3）进行仿真调试，并且提供源码和硬件，这样可以使用户可以轻松的集成一个仿真调试器到自己的项目上而无需担心版权问题。DAPLink不仅拥有仿真调试功能，同时它还具备虚拟串口和拖拽式下载功能（拖拽式下载只支持固件上对应的MCU） DAPLink介绍DAPLink功能介绍 MSC-拖拽式下载 CDC-日志打印、追踪和终端仿真的虚拟串口 HID-CMSIS-DAP兼容式调试接口 WEBUSB HID-CMSIS-DAP兼容式调试接口 MSC拖拽式下载通过复制或保存一个DAPLink支持的格式文件DAPLink的虚拟U盘中，完成后DAPLink设备就会重启。如果发生错误，错误的信息就会存放在FAIL.TXT中 DAPLink的MSC功能支持的文件格式如下： .bin .hex CDC-日志打印、追踪和终端仿真的虚拟串口CDC虚拟串口功能具备普通的串口IC功能，串行端口直接连接到目标MCU，允许双向通信。它还允许通过在串行端口上发送中断命令来重置目标。 串口通讯支持的波特率如下： 9600 14400 19200 28800 38400 56000 57600 115200注：大多数DAPLink还支持这里列出来之外的串口通讯波特率 HID-CMSIS-DAP兼容式调试接口CMSIS-DAP接口可以在任何支持CMSISI-DAP协议的IDE中进行调试，其中包括： pyOCD uVision IAR WEBUSB HID-CMSIS-DAP兼容式调试接口WEBUSB HID-CMSIS-DAP是用于网页上进行调试的接口。 DAPLink官方介绍 Arm Mbed DAPLink是一个开源软件项目，它能够在Arm Cortex架构上的CPU运行编程和调试应用程序。DAPLink是作为应用MCU的SWD或JTAG接口的辅助型MCU，通常称之为接口固件。这种配置几乎在所有的开发板上都可以看到，DAPLink枚举为一个USB复合设备，为开发者的计算机和CPU调试访问端口之间建立了一个桥梁。DAPLink能让开发者具有： MSC-拖拽式编程FLASH闪存 CDC-日志打印、追踪和终端仿真的虚拟串口 HID-CMSIS-DAP兼容式调试接口 WEBUSB HID-CMSIS-DAP兼容式调试接口 更多的功能正在规划兵渐渐展现出来。DAPLink项目不断地在Arm、它的合作伙伴、众多的硬件供应商和世界各地的开源社区的大力开发之下，取代了CMSIS-DAP接口固件项目，你可以尽情使用和贡献。Enjoy! 更多可用的细节信息可查看DAPLink用户指南DAPLink用户指南 兼容性DAPLink接口固件已经运行在许多基于ARM微控制器的硬件接口电路（HICs），它们可用作独立的（调试器）板子或作为开发工具的一部分。一些已知的IO兼容品牌的电路如下： NXP OpenSDA based on K20, K22 and KL26 NXP LPC-Link2 based on LPC11U35 or LPC4322 Segger J-Link OB based on Atmel SAM3U Maxim Epsilon based on MAX32550 - coming soon 版本DAPLink官方的Github仓库创建了许多板级构建（板 = HIC + 目标组合）。季度版本将包含新的特性和修复BUG，一旦根据报告、验证并修复BUG，就会发布独立的修复BUG后的版本无论是季度版本还是修复Bug版本，都会导致生成号递增。许多开发工具包和产品与DaPink接口固件一起运行，或者能够运行DaPink固件。当前发布版本和更新DaPink界面固件的指令是在DaPink发布站点上托管的。发行说明和以前发布版本可以在GITHUB发行版中找到 DAPLink开发环境搭建Windows工具安装本章介绍在Windows下的DAPLink开发环境搭建。安装的工具列表如下，如果有些工具已经安装好可以跳过（注意：软件安装包尽量选择最新版，选择适合自己电脑的32/64位安装包） Python2，版本2.7.9以上，并添加环境变量：下载地址 Git，并添加环境变量：下载地址 Keil MDK-ARM ：下载地址注意：软件安装时尽量使用默认路径 获取源码&amp;生成MDK工程将需要的的工具安装完成后，点击鼠标右键，选择Git Bash Here打开Git命令行界面，按以下步骤输入命令进行操作 下载DAPlink源码到本地 1$ git clone https://github.com/mbedmicro/DAPLink 切换到DAPLink目录下 1$ cd DAPLink 安装虚拟环境 1$ pip install virtualenv 进入拟环境 1$ virtualenv venv 启动虚拟环境下的脚本 1$ venv/Scripts/activate 安装requirements.txt表中的工具 1$ pip install -r requirements.txt 生成MDK工程 1$ progen generate -t uvision 关闭Git命令行界面，在DAPlink目录下有个projectfiles文件夹，里面就是生成的MDK工程，可使用MDK-ARM工具打开 编译源码 打开DAPLink\projectfiles\uvision目录下的工程，如lpc11u35_lpc812xpresso_if工程，如弹出Using an MDK Version 4 Project窗口，选择Migrate to Device Pack 此时会打开Pack Install窗口并自动下载安装相应的固件包，等待安装完成并关闭 编译工程，在lpc11u35_lpc812xpresso_if\build目录会生成.bin和.hex文件 其他问题&amp;解决方法 编译源码的第1步中提示的问题是因为MDK-ARM版本问题引起，可安装对应MDK-ARM的MDK4兼容包解决 ：下载地址 编译源码的第2步中如果提示找不到LPC11U35型号，可在Pack Install窗口搜索LPC1100并安装LPC1100 Series固件包；或者在KEIL官网下载安装LPC1100 Series固件包：下载地址 工程目录projectfiles\uvision\下的文件，以_if结尾的工程是对应工程的应用程序；_bl结尾的是对应工程的Bootloader应用程序，LPC11U35自带Bootloader程序 DAPlink硬件官方DAPLink硬件官方DAPLink硬件是开源的，开源地址 ： Github 目前成熟的DAPLink硬件方案有三个，分别是位于mbed-HDK\Production Design Projects\ARM-mbed\DAPLink目录下的： DIPDAP STDAP SWDAP DIPDAP DIPDAP是基于NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 通过DIPDAP提供的硬件材料，用户可以轻松的制作一个，如果嫌麻烦可以在网上购买成品， 购买地址 STDAPSTDAP是基于ST STM32F103CBT6为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 需要注意的是，目前官方的DAPLink固件中并没有支持STDAP的固件 SWDAP DIPDAP是基于NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 通过DIPDAP提供的硬件材料，用户可以轻松的制作一个，如果嫌麻烦可以在网上购买成品， 购买地址 技新DAPLink硬件 技新DAPLink参考官方DIPDAP硬件设计，以NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能。技新DAPLink设计采用LCEDA，元器件在立创商城平台采购，PCB在嘉立创平台生产。技新DAPLink也是开源的，包括： Gerber文件，可直接打样生产 PCB文件、原理图文件 BOM（元器件采购清单） 技新DAPLink的设计主要是为了解决以下问题： 官方DAPLink硬件在国内购买比较麻烦 官方DAPLink硬件的BOM中的元器件国内购买比较麻烦 提供一个官方DAPLink设计参考 提供一个官方DAPLink方案验证 作为小册的硬件实验使用 技新DAPLink硬件地址： DAPLink_JX技新DAPLink购买地址： 淘宝技新DAPLink开源地址： 码云 DAPLink应用DAPLink固件更新DAPLink固件由两个部分组成 以xxx_bl结尾的.bin文件（Bootloader） 以xxx_if结尾的.bin文件（应用程序） NXP的LPC11U35是自带Bootloader，原装的LPC11U35芯片首次上电时就会自动进入Bootloader，虚拟出一个U盘设备，然后将以应用程序拖进去即可完成烧录，之后就会自动运行应用程序 技新DAPLink固件更新 按住K1（或短接nRST和GND）插入电脑就会识别出一个CRP DISABLDU盘设备，里面有一个firmware.bin文件，将其删除 把第二章的编译产生的DAPLink固件lpc11u35_lpc812xpresso_if_crc.bin（固件位于DAPLink\projectfiles\uvision\lpc11u35_lpc812xpresso_if\build目录下）拖（复制）到U盘中 将DAPLink重新插拔一次（不需要按住K1或短接nRST和GND），就会看到一个DAPLINKU盘设备，固件更新完毕 固件更新后，DAPLINK内有DETALLS.TXT和MBED.HTM两个文件，MBED.HTM是一个网页，DETALLS.TXT是该DAPLink固件的相关信息：1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 0Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 0URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T DAPLink插入电脑后会识别出如下设备（如果有部分设备无法识别请检查系统驱动是否有问题）： MSD–USB大容量存储设备（拖拽式下载） CDC–mbed Serial Port（虚拟串口） HID–符合HID标准的供应商定义设备/USB输入设备（CMSIS-DAP接口） WebUSB：CMSIS-DAP或USB_DFU注：W7和W8系统的CDC驱动需要手动安装， 驱动地址 其他DAPLink固件更新LPC11U35本身自带Bootloader，所以只需要Bootloader的MMSD接口把固件烧录进去即可，对于本身没有自带Bootloader功能的，需要先往里先烧录Bootloader。DAPLink的固件源码编译生成的工程，对于LPC11U35之外没有Bootloader功能的DAPLink硬件提供了Bootloader固件，如DAPLink\projectfiles\uvision目录下的k20dx_bl工程就是k20dx的Bootloader DAPLink在ARM-MDK中的使用DAPLink的CMSIS-DAP接口是用于ARM Cortex内核MCU调试仿真的，只要IDE支持CMSIS-DAP协议接口即可使用DAPLink，这里以ARM-MDK为例，其他的IDE也类似使用，调试仿真使用的是DAPLink的CMSIS-DAP接口功能 DAPLink作为仿真器连接目标设备，如STM32F103C8T6最小系统板 打开STM32F103C8T6的ARM-MDK例程 打开Options for Target选项，在Debug栏下的Use选项选择CMSIS-DAP Debugger 点击Settings，Debug栏设置如下图，点击OK完成配置，之后即可编译下载/调试 DAPLink的MSD命令使用DAPLink允许通过MSD接口来给它一些简单的命令。复制一个指定命名的文件通过MSD接口到DAPLink，可以使DAPLink执行一个动作或一个永久有效配置，文件的内容可以被忽略（可以发送一个空文件） MSD的命令只有在下面状态下才有效 插入DAPLink，再按住K1，然后把相应的.act或.cfg文件复制到MSD接口 在打automation-allowed模式下，把相应的.act或.cfg文件复制到MSD接口 MSD命令有两种 .act文件，触发DAPLink一个Action（动作） .cfg文件，配置DAPLink一个Configuration（设置） Action命令start_bl.act 该文件将强制进入Bootloader，相当于拔下DAPLink，按住K1再插上。如果DAPlink已经处于Bootloader，则该命令无效 start_if.act 该文件将强制DAPLink重新进入DAPLink接口模式。它相当于拔下USB电缆，并将其插入。如果已经处于DAPLink接口模式，则此命令无效 assert.act 该文件可以用来测试DAPLink的assert实用程序。当您将该文件复制到DAPLink MSD驱动器时，DAPLink将生成对util_assert()方法的调用。assert调用导致DAPLink MSD驱动器重新加载一个附加文件ASSERT.TXT，出现在驱动器的根部。这个文件详细说明了断言失败发生的地方(源文件，行号) refresh.act 该文件强制重新加载DAPLink MSD驱动器 erase.act 该文件触发对目标FLASH的擦除 Configuration命令auto_rst.cfg 该文件用于配置自动复位模式，默认情况下自动复位是禁止的 hard_rst.cfg 该文件用于关闭自动复位模式，默认情况下自动复位是禁止的 auto_on.cfg 该文件用于打开automation-allowed模式，再该模式下可以出发DAPLink的MSD命令，而不需要按住K1案件。此外，Bootloader更新只允许再该模式下运行 auto_off.cfg 该文件用于关闭automation-allowed模式，automation-allowed模式默认是关闭的 ovfl_on.cfg 该文件用于打开串口溢出报告。再串口通讯过程中，如果主机PC没有以足够快的速度从DAPLink读取数据，并且发生溢出，则文本&lt;DAPLink: overflow &gt;将出现在串行数据中。串行溢出报告默认关闭 ovfl_off.cfg 该文件用于关闭串口溢出报告 MSD命令使用 使能automation-allowed模式。新建文本文档并重命名为auto_on.cfg，插入DAPLink并按按K1，然后把auto_on.cfg文件拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Remount count: 1 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 1URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 触发一个Action。新建文本文档并重命名为refresh.act，将该文档拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Remount count: 2 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 2URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 配置一个Configuration。新建文本文档并重命名为refresh.act，将该文档拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Overflow detection: 1; Remount count: 3 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 1Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 3URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 注：其他MSD命令使用也如上配置 DAPLink其他功能介绍CDC虚拟串口DAPLink带有虚拟串口功能，可用于与目标设备进行串口通讯，使用方法与其他UDB转TTL的模块一样，支持的比特率有：123456789600144001920028800384005600057600115200 注：大多数DAPLink还支持这里列出来之外的串口通讯波特率 MSC拖拽式下载功能DAPLink带有拖拽式下载功能，但是该功能通常只针对独立的目标设备，如固件lpc11u35_lpc812xpresso_if_crc.bin的拖拽式下载是针对lpc812xpresso目标的，如果想支持其他的目标就需要对DAPLink固件进行修改移植，参考文档 其他功能DAPLink还提供了非常多的功能和应用，如自动化测试、添加一个新板支持、添加一个新设备、移植到新的硬件电路等，其中的操作都有独立的文档讲解，本章介绍的固件更新和DAPLink的MSD命令使用也只是其中一部分功能，具体可参考： DAPLink官方文档]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>DAPLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo:搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2FHexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Create Hexo需要环境环境安装是只需一直点Next即可 PC:Windows10 64-bit Git:Download 2.18.0 for Windows Node.js:Windows Installer(.msi)64-bit 安装Hexo安装好Git和Node.js环境后，打开Git Bash，然后输入如下命令安装Hexo1npm install hexo-cli -g 输入如下命令查看是否安装成功1hexo -v 出现下面内容，即为安装成功12345678910111213141516hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.6.0v8: 6.7.288.46-node.13uv: 1.21.0zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.32.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 接下来在G盘新建blog文件夹（可根据个人而定），用于作为hexo博客目录。现在在Git Bash进入到blog文件夹，然后在里面初始化为hexo博客目录123cd g:bloghexo init 初始化成功信息如下1234added 397 packages from 485 contributors and audited 2021 packages in 51.695sfound 0 vulnerabilitiesINFO Start blogging with Hexo! 然后安装依赖包1npm install 出现下面信息即安装完成12audited 2021 packages in 2.965sfound 0 vulnerabilities 下面输入命令来生成静态页面1hexo generate 输入启动服务命令1hexo server 可以看到一下信息12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 现在打开浏览器访问http://localhost:4000/即可看到，在Git Bash按Crl+c就会关闭网站。 note:如果出现防火墙提示，放行就可以了 部署网站到GithubGithub仓库创建 新建一个仓库，命名方式：userName+’github.io’ 点击Create Repository后，选择Setting进入设置 在Github Pages下点击Choose a theme选择一个主题 此时返回仓库再点击Setting既可以查看到github分配的域名 将本地的博客发布到github上回到Git Bash，修改博客根目录的_config.yml文件，修改如下1234deploy: type: git repository: https://github.com/LGG001/LGG001.github.io.git branch: master 然后安装部署插件1npm install hexo-deployer-git —save 最后部署到github上1hexo d 补充：生成SSH Key在Git Bash中输入命令来生产SSH密钥1ssh-keygen -t rsa -C &quot;1058901869@qq.com.com&quot; 接着会要求输入密语字符串，直接回车跳过即可。然后会让输入2次口令，这里也直接输入两次回车跳过（使用3次回车就会生产一份公钥id_rsa.pub和一份密钥id_rsa，这两份密钥位于根目录下的.ssh目录下） 公钥需要在Github上的Settings--&gt;SSH and GPG keys上配置，把生成好的公钥id_rsa.pub复制到key输入框中，然后为key起一个title来区分每个key。生成后Github会发一封邮件提醒 接下来回到博客根目录1cd g:blogs 修改_config.yml文件1vim _config.yml 修改deploy部分，如下1234deploy: type: git repository: git@github.com:LGG001/LGG001.github.io.git branch: master 最后重新输入如下命令来重新发布到Github上123hexo cleanhexo ghexo d 输入网址https://lgg001.github.io/即可访问博客了 发表文章新建文章在博客的目录文件夹下进入Git Bash，然后输入hexo new “博文名字”，如hexo new “Hexo:搭建个人博客” 在blogs\source_post目录下就会再到”博文名字”.md的文件，该文件的内容是使用MarkDown格式的，使用MarkDown编辑器编辑。个人推荐：MarkDownPad2 添加分类在blogs\scaffolds目录下，修改post.md文件1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags: 观察成的”Hexo:搭建个人博客”文章内容123456---title: &apos;Hexo:搭建个人博客&apos; #文章页面显示的名称categories: #文章分类目录date: 2018-07-20 23:23:06 #文章生成时间tags: #文章标签--- 在文章下面就可以写自己的内容了。 如果想给文章添加图片的效果，在文章里面的头上添加photos选项即可123456789---layout: phototitle: &apos;Hexo:搭建个人博客&apos; #文章页面显示的名称categories: #文章分类目录date: 2018-07-20 23:23:06 #文章生成时间tags: #文章标签photos: - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg--- 使用描述、摘要描述和摘要的使用如下123456789title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述以上是摘要&lt;!--more--&gt;以下是余下全文 使用图片在Git Bash输入1npm install hexo-asset-image --save 重新创建一个博客名字，然后发现Hexo\source_posts下多了一个与博客名字相同的空文件夹,然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可. 安装主题（Next）安装Next主题关于Next的详细内容可以参考Next官方文档 安装Next主题只需要一条命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，打开博客的配置文件_config.yml文件，修改主题为next1theme: next 然后输入hexo s --debug在本地查看预览效果 打开themes\next目录，编辑主题的配置文件_config.yml 重新发布主题到Github上123hexo cleanhexo ghexo d]]></content>
  </entry>
</search>
