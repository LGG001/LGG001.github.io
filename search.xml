<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Typora-markdown编辑器&阅读器]]></title>
    <url>%2F2019%2F05%2F08%2FTypora-markdown%E7%BC%96%E8%BE%91%E5%99%A8%26%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Typora简介Typora是一个漂亮的、简单的、功能强大的markdown编辑器&amp;阅读器，目前还在测试期间，可以免费使用。Typora具备实时预览功能，支持大部分的markdown语法，还支持嵌入HTML格式，数学公式，流程图，甘特图等各种酷炫功能，同时还有许多独具特色的主题可供免费使用，如果还不满意也可以参考http://theme.typora.io/doc/自己写一个主题来使用 Typora下载&amp;安装Typora有分别针对MAC、WINDOWS、LINUX系统的安装包，可根据需求下载相应的安装包 Typora官方下载地址https://www.typora.io/ Markdown语法Typora支持Markdown的大部分语法，同时又具有自己的特色语法，如制图、数学表达式、嵌入HTML语法等。Typora软件上的工具栏可以让用户更便捷地应用Markdown语法来编写文档，下面将讲述Typora相关的Markdown基本语法以及Typora独具特色的一些语法，如果想详细了解可以阅读官方文档，地址：http://support.typora.io/Markdown-Reference/ 注：作者使用的系统位window操作系统 Typora的markdown基本语法段落和换行符段落可以由一行或多行文本组成，在Typora中段落通过一个空行分割，或者在段落的末尾留下两个空格，或插入&lt;br/&gt; 符号 注：建议使用在每一段末尾加两个空格的方式，或多空几行 标题Typora支持6个等级的标题，一级标题在行开头使用一个#加一个空格，后面就是标题内容，二级标题在行开头使用两个##加一个空格，后面就是标题内容 123# 这是一级标题 ## 这是二级标题 ##### 这是五级标题 引用Markdown使用电子邮件样式的&gt;字符加空格进行块引用，如下： 12&gt; 这是第一个段落引用&gt; 这是第二个段落引用 列表列表分为无序列表和有序列表两种。无序列表使用*加空格或+加空格或-加空格的方式，有序列表使用1.加空格方式，如下： 123456789### 无序列表 * Red * Green * Blue ### 有序列表 1. Red2. Green 3. Blue 任务列表任务列表使用- [ ]的方式，标志已完成任务使用- [x]的方式，如下： 12345- [ ] 这是一个任务列表- [ ] 列表语法需求- [ ] 标准语法- [ ] 未完成- [x] 已完成 代码块Typora只支持Github Flavored Markdown的代码块格式，输入三个`符号然后按回车即可，然后可以在代码块选择一个语言标识符，然后就会语言标识符进行语法高亮 123456789101112​```C#include &lt;stdio.h&gt;int main()&#123; int a[10] = &#123;3,4,8,1,5,9,2,7,6,0&#125;; int i; for(i = 0; i &lt; 10; i++) printf("%d\n", a[i]);&#125;​ 1234567891011121314151617181920### 表格 输入| 标题1 | 标题2 |然后按回车就会自动生成表格，然后可以通过表格左上角和右上角的图标选项可以多表格进行快速操作 | 标题1 | 标题2 | 标题3 || :---: | :---: | :---: || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 |### 附注 ``` 通过输入：[^footnote]来实现附注[^footnote]: Here is the *text* of the **footnote** 水平线输入***或—然后按回车就会在下方生成一条水平线 YAML Front Matter这是一种前页格式，一般使用在书写博客的方式，使用—来概括前页的内容，比如本篇博客的前页包括作者信息、分类、图片、日期等信息，但是实际的文档中是不会显示出来的 目录(TOC)输入[toc]然后回车就可以生成文档的目录 链接Markdown支持两种链接：内联和引用。两种类型都是使用方括号来指示包含的链接，链接存放在紧跟着的圆括号里面 内联链接使用如下： 123This is [an example](https://www.baidu.com/) inline link[This link](https://www.baidu.com/) has no title attribute 效果如下（按住Ctrl点击带链接的内容即可跳转到链接中去）： This is an example inline link This link has no title attribute 引用链接使用如下： 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label on a line by itself like this:[id]: http://example.com/ &quot;Optional Title Here&quot; 效果如下（按住Ctrl点击带链接的内容即可跳转到链接中去）： This is an example reference-style link. Then, anywhere in the document, you define your link label on a line by itself like this: 图片引用插入图片的方式：![图片的描述](图片的url或路径) 斜体Markdown使用*和_作为强调，使用*或_包括的内容会变为斜体 123*single asterisks*_single underscores_ single asterisks single underscores 加粗Markdown使用**和__作为加粗语句，使用**或__包括的内容会变为粗体 123**double asterisks**__double underscores__ double asterisks double underscores 代码Markdown使用`符号包含代码会特殊显示代码 1Use the `printf()` function Use the printf() function 删除线Markdown使用~~包含的内容会在内容中加一条删除线 1~~这是显示删除线的例子~~ 这是显示删除线的例子 下划线使用HTML的下划线语法可以在Typora中实现添加下划线的功能 1&lt;u&gt;这是一个显示下划线的例子&lt;/u&gt; 这是一个显示下划线的例子 Typora使用Markdown编写数学表达式Typora支持使用Tex/LaTeX语法渲染一般数学表达式，渲染过程由MathJax处理。数学块使用$$符号包括住，如下12345678910$$\begin&#123;align*&#125;y = y(x,t) &amp;= A e^&#123;i\theta&#125; \\&amp;= A (\cos \theta + i \sin \theta) \\&amp;= A (\cos(kx - \omega t) + i \sin(kx - \omega t)) \\&amp;= A\cos(kx - \omega t) + i A\sin(kx - \omega t) \\&amp;= A\cos \Big(\frac&#123;2\pi&#125;&#123;\lambda&#125;x - \frac&#123;2\pi v&#125;&#123;\lambda&#125; t \Big) + i A\sin \Big(\frac&#123;2\pi&#125;&#123;\lambda&#125;x - \frac&#123;2\pi v&#125;&#123;\lambda&#125; t \Big) \\&amp;= A\cos \frac&#123;2\pi&#125;&#123;\lambda&#125; (x - v t) + i A\sin \frac&#123;2\pi&#125;&#123;\lambda&#125; (x - v t)\end&#123;align*&#125;$$ 效果如下： 注：使用内联数学功能需要把文件–&gt;偏好设置选项的Markdown扩展语法中的内联公式勾选 Typora使用Markdown制图Typora支持图表相关的扩展，可以在文件–&gt;偏好设置选项的Markdown扩展语法中勾选图标选择，然后进行使用。Typora可以绘画序列图、流程图、Mermaid图、甘特图等，以甘特图为例： 123456789101112131415161718192021222324252627282930​```mermaid%% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h​ ` 效果如下： Typora的HTML支持Typora主题安装]]></content>
      <categories>
        <category>软件安装类</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uFun学习板初体验-uFun学习板简介]]></title>
    <url>%2F2019%2F04%2F01%2FuFun%E5%AD%A6%E4%B9%A0%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C-uFun%E5%AD%A6%E4%B9%A0%E6%9D%BF%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[uFun学习板硬件介绍uFun采用STM32F103RCT6为核心进行设计，PCB的面积只有4*6cm大小并采用沉金工艺，板载有RGB、LED、加速度传感器、触摸IC及触控点设计、蜂鸣器、运放、TF卡卡槽、CH340…等等器件，在后续部分会一一分析uFun学习板的硬件电路设计。以uFun进行STM32的入门学习可以说是既有挑战又有趣的事，uFun的原理图可以在文末链接中下载 STM32F103RCT6uFun学习板采用STM32F103RCT6作为主控。STM32F103RCT6的外围电路设计中，时钟采用与CH340共用12MHz时钟（uFun板上使用了焊锡作跳线，可能由于设计的小失误）。系统启动方式又BOOT0&amp;BOOT1引脚决定，该引脚连接到一个拨码开关上，可根据需求决定系统启动方式。程序下载可使用串口或SWD下载方式，uFun上带有USB转TTL芯片CH340可用于ISP，同时J2（从左到右VCC、GND、SWCLK、SWDIO、NRST）的SWD接口也可下载。系统供电采用AMS1117-3.3v稳压LED把电源稳压到3.3V供电，BAT供电口接入一个超级电容，用于断电时维持RTC的正常工作，需要注意的是，数字部分采用的是上述供电，模拟部分（运放供电）采用的是另外一个通过SP6203-3.3稳压到3.3V使用 外围电路相关接口uFun学习板上集成许多外围电路，包括传感器、IC等。STM32F103RCT6的外设资源非常丰富，因此通过与传感器通信和控制外围期间可以使得学习更加有趣深入。STM32F103RCT6的IO根据功能与相关的器件连接，如带有PWM输出功能的IO口与RGB连接、带有ADC功能的IO口与运放进行连接等，资源分配合理，便于学习开发。uFun还有一个mini_pci_e接口，可用于后面进行扩展 uFun学习板开发环境介绍STM32F103RCT6的开发环境有很多种，如GCC、IAR For ARM、KEIL-MDK等等，本系列课程采用的开发环境是KEIL-MDK。KEIL-MDK是集成开发环境（IDE），里面集成了汇编器、编译器、链接器等等，用户可以直接在KEIL-MDK编写程序，然后编译下载，就可使程序在uFun上运行。KEIL-MDK支持众多下载用具，如常见的ST-LINK、J-LINK、DAPLink等，通过下载工具连接PC与uFun，然后在KEIL-MDK中稍微配置一下就可以实现一键下载。关于开发环境如何搭建，后续会有介绍 uFun学习板资料下载uFun官方提供了原理图、测试程序等资料，这里提供一个百度云的下载链接方便大家获取，后续过程中的资源也会在文章的末尾分享给大家。关于测试程序，经过下载测试是可以使用的，现象也是跟工程中readme文件描述差不多，但是部分功能可能不是很稳定，如TF卡（有时候会检测不到）。编程风格方面。官方有一个编程规范的PDF，编程风格是一个很重要的习惯，函数和变量的命名可以参考大小驼峰或帕斯卡命名法 资料链接：https://pan.baidu.com/s/1hvisSu4TMsK_560qf8omNQ提取码：nj2i]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ufun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式硬件通信接口-UART]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3-UART%2F</url>
    <content type="text"><![CDATA[UART协议简介UART(Universal Asynchronous Receiver/Transmitter)，通用异步收发器。UART在一开始发明出来的时候用作电脑硬件的一部分，主要作用是将数据通过串行通信和并行通信间作传输转换，后来UART作为微处理器的外设应用非常广泛，同时在UART上追加同步的时钟信号，称为USART（Universal Synchronous Asynchronous Receiver Transmitter）。UART它包括RS232、RS449、RS422和RS485等接口标准规范和总线规范，是异步串行通信口的总称。可以理解为UART通信协议是软件上的通信网络中的数据链路层，表示数据传输协议。而RS232、RS485是通信接口的电器特性和连接特性、机械特性等硬件上的范畴，属于物理层 UART协议特点UART通信可以是半双工、全双工，在空闲状态（没有数据传输期间）保持高电平，表示传输线路正常。每一个字符为一帧数据，以逻辑低电平为开始比特，然后是数据比特，可选的奇偶校验比特，最后是一个或多个停止比特（逻辑高电平）。大部分的应用都是先传输低位数据比特 UART协议应用UART应用是非常广泛的，在早期的电脑中都会带一个RS232的接口，后来变为USB口。目前市场上绝大部分的微处理器（MCU）都带有UART硬件，可用于通信或应用程序下载。需要注意的是MCU上的UART是TTL电平 UART协议时序UART时序包含：起始位、数据位、奇偶校验位（可选）、停止位。在无数据传输的期间（空闲状态下），数据线保持高电平；通信过程中，先发送1bit起始位（低电平），接着发送数据位（数据位多少由用户配置决定，通常为8bit，也就是1Byte），发送完数据位后接着发送1bit奇偶校验位1bit（根据通信决定可选择不发送，一般都配置为无奇偶校验），最后发送停止位(通常位1bit)。数据位选择、奇偶校验位选择和停止位选择如下表 起始位 数据位 奇偶校验位 停止位 1(bit) 5、6、7、8(bit) 奇校验或偶校验(1bit)、无 1、1.5、2(bit) 注：奇偶校验位-当配置为奇校验时，数据位中数据‘1’的个数+奇偶校验位 = 奇数；偶校验同理 数据帧结构UART通信配置：起始位1bit+数据位8bit+无奇偶校验+停止位1bit。通信数据帧如下图： 通信速率UART的通信速率是以波特率位单位衡量的，UART一般通信速率使用9600、115200。需要特别说明的是：UART通信中，比如波特率是9600bps，但是不意味着是9600bit/s，因为使用的波特率单位bps与平常的比特率单位bit/s是不一样的，波特率指的是每秒钟传送的码元符号的个数，是衡量数据传送速率的指标，它用单位时间内载波调制状态改变的次数来表示，比特率指的是每秒传送的比特(bit)数 UART通信中，1个bit表现为高电平或低电平，在这种情况下是9600bps = 9600bit的，一帧数据 = 起始位1bit+数据位8bit+无奇偶校验+停止位1bit = 10bit，9600bps的实际有效数据就是9600/10 = 960Byte 注：当一个一个码元符号表示两个bit时，比特率 = 波特率 x 2 UART协议在MCU中的应用目前市场上大部分的MCU都带有UART外设，以STM32F103RCT6型号为例，该型号MCU带有数个USART（Universal Synchronous Asynchronous Receiver Transmitter），比UART多了一个时钟同步信号线（该功能比较少用），还有有CTS与RTS信号引脚，可用于流控[^有软件和硬件两种]。UART大量应用在数据收发的通信场合，因此一个好的算法处理收发过程的数据是很必要的，下面介绍一个常用的队列结构在UART收发上的应用 下面例子使用的环境如下： Windows10 ARM KEIL MDK V5.25 Thermal Printer MainBoard V1.0（STM32F103RC开发板也可以直接使用） DAPLink（或其他支持SWD下载方式的下载器,如ST-LINK） 友善串口调试助手（支持串口调试的终端都可以） 注：如果选择非DAPLink下载器（DAPLink自带虚拟串口），则还需要一个USB转TTL来连接PC与开发板 UART基础配置例程使用STM32F103RCT6中的USART1口，基本配置为（起始位时通讯中必须存在的）： 波特率115200 8位数据位 一位停止位 无奇偶校验 无流控 全双工模式 开启接收中断 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @函数名 USART1_Init * @功 能 初始化串口，波特率115200，8位数据为，1位停止位，无奇偶校验 * @参 数 无 * @返回值 无 */void USART1_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; // 定义一个GPIO_InitTypeDef类型的变量 USART_InitTypeDef USART_InitStructure; // 定义一个USART_InitTypeDef类型的变量 NVIC_InitTypeDef NVIC_InitStructure; //定义中断向量结构体 /* 允许GPIOA和USART1的时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); /* 配置USART1 */ /* 配置PA9(TXD) */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; // 选择PIN9 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 50MHz速度 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); // 初始化配置 /* 配置PA10(RXD) */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; // 选择PIN10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 选择浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); // 初始化配置 /* 配置USART1的NVIC */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //嵌套向量中断控制器组配置为2 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; //配置通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//抢占优先级：1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //子优先级：1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能通道 NVIC_Init(&amp;NVIC_InitStructure); //初始化配置 /* 配置串口USART1的模式 */ USART_InitStructure.USART_BaudRate = 115200; // 波特率115200 USART_InitStructure.USART_WordLength = USART_WordLength_8b;// 8个数据位 USART_InitStructure.USART_StopBits = USART_StopBits_1; // 1个停止位 USART_InitStructure.USART_Parity = USART_Parity_No ; // 无奇偶校验 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 无硬件流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, &amp;USART_InitStructure); //把上面配置的参数带进函数里面初始化串口 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //使能接收中断 USART_Cmd(USART1, ENABLE); //打开串口1&#125; 环形队列应用USART配置完毕后，开始实现队列结构，队列结构由五部分组成： 12345678typedef struct Circular_Queue_Str&#123; uint8_t *BuffHead; //缓冲区首地址 uint16_t WritePtr; //写入指针（位置） uint16_t ReadPtr; //读取指针（位置） uint16_t Count; //已使用数据量计数器 uint16_t BuffSize; //缓冲区大小&#125;CirQueue_Str; 在实际使用队列前，需要初始化队列，收发数据过程也伴随着不断入队和出队过程，相关队列函数实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * @函数名 Circular_Queue_Init * @功 能 初始化队列 * @参 数 queue：队列结构， bufHead：队列数组首地址， bufSize：队列大小 * @返回值 无 */void Circular_Queue_Init(CirQueue_Str *queue, uint8_t *bufHead, uint16_t bufSize)&#123; queue-&gt;BuffHead = bufHead; //队列数组首地址 queue-&gt;BuffSize = bufSize; //队列数组大小 queue-&gt;ReadPtr = 0; //队列读指针指向首地址 queue-&gt;WritePtr = 0; //队列写指针指向首地址 queue-&gt;Count = 0; //队列计数器清零&#125;/** * @函数名 Circular_Queue_IsEmpty * @功 能 判断队列是否为空 * @参 数 queue：队列结构 * @返回值 计数器是否等于0的结果，空 = 1，非空 = 0； */uint8_t Circular_Queue_IsEmpty(CirQueue_Str *queue)&#123; return (queue-&gt;Count == 0); //返回队列计数器是否等于0的结果&#125;/** * @函数名 Circular_Queue_IsFull * @功 能 判断队列是否为满 * @参 数 queue：队列结构 * @返回值 计数器是否等于队列大小的结果，满 = 1，非满 = 0； */uint8_t Circular_Queue_IsFull(CirQueue_Str *queue)&#123; return (queue-&gt;Count == queue-&gt;BuffSize); //返回队列计数器是否等于队列大小的结果&#125;/** * @函数名 Circular_Queue_Clear * @功 能 清空队列 * @参 数 queue：队列结构 * @返回值 无 */void Circular_Queue_Clear(CirQueue_Str *queue)&#123; queue-&gt;ReadPtr = 0; //队列读指针指向首地址 queue-&gt;WritePtr = 0; //队列写指针指向首地址 queue-&gt;Count = 0; //队列计数器清零&#125;/** * @函数名 Circular_Queue_Enter * @功 能 入队 * @参 数 queue：队列结构，data：数据 * @返回值 无 */void Circular_Queue_Enter(CirQueue_Str *queue, uint8_t data)&#123; if(Circular_Queue_IsFull(queue)) //判断队列是否满 &#123; printf("the queue is full \n"); return; &#125; *(queue-&gt;BuffHead + queue-&gt;WritePtr) = data;//数据入队 __disable_irq(); //禁能所有中断 queue-&gt;Count++; //队列计数器加一 queue-&gt;WritePtr = (queue-&gt;WritePtr + 1) % queue-&gt;BuffSize; //写指针加一，循环队列的操作方法 __enable_irq(); //解禁中断&#125;/** * @函数名 Circular_Queue_Exit * @功 能 出队 * @参 数 queue：队列结构 * @返回值 temp：队列数据或出错信息 */uint16_t Circular_Queue_Exit(CirQueue_Str *queue)&#123; uint8_t temp; if(Circular_Queue_IsEmpty(queue)) &#123; printf("the queue is empty \n"); return 0xffff; &#125; temp = *(queue-&gt;BuffHead + queue-&gt;ReadPtr); //数据出队 __disable_irq(); //禁能所有中断 queue-&gt;Count--; //队列计数器减一 queue-&gt;ReadPtr = (queue-&gt;ReadPtr + 1) % queue-&gt;BuffSize; //读指针加一，循环队列的操作方法 __enable_irq(); //解禁中断 return temp; //返回数据&#125; 相关队列函数实现后，开始初始化队列。初始化队列需要由一个数据缓冲区，以及缓冲区大小和一个队列结构体三个参数，可以定义在USART配置的文件中： 123#define USART_BUFF_SIZE 256uint8_t USART_Buff[USART_BUFF_SIZE]; //定义缓冲区数组CirQueue_Str my_queue; //定义队列 然后对USART和QUEUE进行初始化： 1234567891011/** * @函数名 USART1_Config * @功 能 串口配置 * @参 数 无 * @返回值 无 */void USART1_Config(void)&#123; USART1_Init(); //初始化串口 Circular_Queue_Init(&amp;my_queue, USART_Buff, USART_BUFF_SIZE); //初始化队列&#125; 当接收到数据时，会引发USART的接收中断，在中断中把数据入队： 123456789101112131415/** * @函数名 USART1_IRQHandler * @功 能 串口1中断函数 * @参 数 无 * @返回值 无 */void USART1_IRQHandler(void)&#123; //串口空闲中断 if(USART_GetFlagStatus(USART1, USART_IT_RXNE) != RESET) &#123; USART_ClearITPendingBit(USART1,USART_IT_RXNE); //清除中断标志 Circular_Queue_Enter(&amp;my_queue, USART_ReceiveData(USART1)); //入队 &#125;&#125; 最后在主函数中判断队列是否存在数据，存在数据则发送出去： 123456789101112131415161718192021222324/** * @函数名 main * @功 能 主函数入口 * @参 数 无 * @返回值 无 */int main(void)&#123; uint8_t temp; //定义变量 USART1_Config(); //串口初始化 while(1) &#123; if(!Circular_Queue_IsEmpty(&amp;my_queue)) //判断队列书否存在数据 &#123; while(my_queue.Count != 0) //队列存在Count个数据 &#123; temp = Circular_Queue_Exit(&amp;my_queue); //把数据出队（1Byte） USART_SendData(USART1, (uint8_t) temp); //发送数据 while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); //等待发送完成 &#125; &#125; &#125;&#125; 效果如下所示：]]></content>
      <categories>
        <category>mcu编程类</category>
      </categories>
      <tags>
        <tag>嵌入式硬件通信接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式硬件通信接口-IIC]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3-IIC%2F</url>
    <content type="text"><![CDATA[IIC协议简介IIC（Inter-Integrated Circuit）也叫I2C，集成电路总线。在1982年由飞利浦半导体公司（现在叫恩智浦半导体）发明的一种同步的，多主机，多从机，数据包交换，半双工，串行计算机总线。于2006-10-10正式开源 IIC协议特点IIC应用只需要两根双向的集电极开路或漏极开路线：串行数据线（SDA）和串行时钟线（SCL）与上拉电阻。虽然系统允许采用各种工作电压，不过一般IIC应用在+5V与+3.3V的系统 IIC总线的节点数量有地址空间与总线上的电容（不超过400pf）决定的，这也约束了通讯距离在几米之内。同时为了有相对较高的阻抗和较低的噪声要求有一个相同的对地点平，这再次约束实际应用只能在同一块板子/PC上 IIC协议是一种带有时钟（SCL）和寻址的数据（SDA）总线，该总线在节点中充当两个角色：主机和从机： 主机节点-产生时钟信号并发起与从节点的通信 从机节点-接收时钟信号并响应主机发出的寻址 IIC总线是多主机总线，这意味着可以存在任意数量的主机节点。同时，可以在消息之间更改主角色和从角色（发送停止信号后），对于设定好的总线设备可以有四种操作模式，尽管实际通信只采用一到两种： 主机发送-主机节点发送数据到从机 主机接受-主机节点接受从机的数据 从机发送-从机节点发送数据到主机 从机接收-从机节点接受主机的数据 数据通信过程中，IIC总线上的主机控制SCL产生脉冲然后发送起始START信号通知从机开始通信，然后发送要与之通信从机的（7位/10位）地址&amp;读写位，数据传输阶段接收方每接收一字节数据后需要控制SDA产生应答ACK/不应答NACK信号，最后主机发送STOP停止信号结束本次通信 IIC定义了基本的通信类型，每次都以START（起始）信号为开始，STOP（停止）信号为结束： 单个消息-主机向从机写入数据 单个消息-主机向从机读取数据 组合格式-主机向一个或多个从机发出至少两个读/写操作 在一次组合传输中，每次读/写都是以STSRT（起始）信号和从地址开始，第一个之后的STSRT（起始）信号也叫重复起始条件，在之前没有STOP（停止）信号，这就是从机判断下一次消息是同一次传输的一部分的方法从机只响应其产品文档中指定的特定消息 地址和数据字节是最高位先发送；起始位是SCL位于高电平时，SDA由高变低来表示；停止位是SCL位于高电平时，SDA由低变高来表示；其他的情况中，SDA的变化只发生在SCL位于低电平时 在实际的硬件设计中，SCL线与SDA线都采用开漏设计，因此它们需要上拉电阻。当输出逻辑0时把线拉到GND；当输出逻辑1时状态是浮空的，因为由上拉电阻存在会变为高。线不会主动变为高（只能被上拉电阻拉高），这种连接方式允许多个节点接入到总线上而不会因为信号引起短路。高速系统（和其他一些系统）可以使用电流源来取代SCL或SCL和SDA的上拉电阻来适应更高的总线电容和更快的上升时间 从上述可以得出一个结论：多个节点可以同时驱动线路。如果任意一个节点把线拉低，那么该线就会处于低状态，当有节点试图把线拉高就会检测出此线处于低状态，从而得出有其他节点正在使用总线。这种情况发生在SCL线上时，被称为时钟延展，作为从机流控制机制；当发生在SDA线上时，被称为仲裁，作为一次通信只能有一个发送方 IIC的通信的运行模式可能会是下面几种之一。100kbit/s标准模式（Standard Mode）是所有设备都兼容的，也一直被使用，但是在同一总线上同时具有不同功能的设备可能会导致问题，如下： 快速模式（Fast Mode）是大部分设备兼容的，并简单地收缩了几个时间参数来达到400kbit/s的速度。快速模式广泛被从机设备支持，因此，只要总线电容和上拉强度允许，主机就能使用它 快速模式+（Fast Mode Plus）能达到1Mbit/s，使用更强大的（20ma）驱动和上拉来实现加快上升和下降沿时间，如果减少通讯是的下拉强度能实现与标准模式和快速模式兼容 高速模式（High Speed Mode）3.4Mbit/s在同一总线上与正常IIC设备兼容，但是要求在高速传输时主机有一个主动上拉的时钟线，第一个数据位以正常的开漏上升时钟沿传输，该时钟可能被延展，剩余的7个数据位和应答位，主机在适当驱动时钟线为高，从机不能对其延展。所有高速传输之前都有一个使用标准/高速传输单字节的“master code”，这个coed有三个用途： 告诉高速从机设备更改为高速时间设置规则 它确保快速/正常速度设备不会尝试参与传输（因为与他们的地址不匹配） 因为它标识了主代码(有8个主代码，每个主代码必须使用一个不同的主代码)，所以它确保仲裁在传输的高速部分之前完成，因此高速部分不需要考虑这种能力 超快速模式（Ultra-Fast Mode）本质上时一个只写的IIC子设备，它与其他模式不适合兼容，除了容易添加到现有的IIC硬件设计。只允许有一个主机，并且在任何时候都主动驱动时钟线和信号线以达到5Mbit/s的传输速率，时钟延展、仲裁、读传输、和应答都被忽略。它的主要作用于动态LED显示，其中传输错误只会导致一个无关紧要的短暂视觉故障，与其他IIC总线模式相似之处在于： 起始和停止条件用于划分传输 IIC地址允许多从机设备挂在，但与SPI总线不同的是没有从机选择信号 每个字节发送的第九个时钟脉冲用于表示应答位 IIC协议应用IIC适用于外围设备简单和制造成本比速度重要的场合，常见的IIC应用有： 通过小型ROM配置表描述可连接设备，以支持“即插即用”操作，如 双内联内存模块(DIMMs)上的串行状态检测(SPD) EEPROMs 通过VGA、DVI和HDMI连接器为监视器提供扩展显示识别数据(EDID) 通过SMBus对PC系统进行系统管理 SMBus引脚在传统PCI和PCI Express连接器中都有配置 访问实时时钟和NVRAM芯片来保存用户设置 访问低速的ADCs与DACs 改变显示器中的对比度、色相和色彩平衡设置（通过显示数据通道） 改变智能扬声器的音量 控制小的（如功能性手机）OLED或LCD显示器 读取硬件监视器和诊断传感器，如风扇的速度 开/关系统各部件的电源 微控制器（MCU）中的IIC特点是只需要两个通用的IO口就能实现对多个设备进行控制，能有效的节省资源，相对的缺点就是速度较慢 IIC协议版本IIC协议版本发展历史: 1982年，原始的100kbin/s的IIC系统作为一个简单的内部总线系统建立控制与各种飞利浦电子芯片被创建出来 1992年，版本1；添加400kbit/s快速模式（Fm）和10位地址模式增加兼容到1008个节点，这是第一个标准的版本 1998年，版本2；添加3.4Mbit/s高速模式（Hs）和电压电流节能需求 2000年，版本2.1；延续版本2，没有重大的功能改变 2007年，版本3；添加1Mbit/s增强版快速模式（Fm+）（使用20ma驱动）和驱动ID机制 2012年，版本4；添加5Mbit/s超快速（UFm），使用新的USDA（数据线）和USCL（时钟线），使用上拉逻辑，取消上拉电阻和添加一个制定的制造商ID表。它是一个单向总线 2012年，版本5；纠正错误 2014年，版本6；纠正两个图形，这是最新的协议标准 IIC协议时序IIC的传输在串行数据线（SDA）和串行时钟线（SCL）上完成，IIC在通信过程有两个角色：主机和从机；主机是控制SCL线的一方。IIC通信的数据是高位先发送 IIC的起始&amp;结束时序IIC的数据传输开始与一个起始START位，结束于一个停止STOP位。起始位时序：在SCL处于高状态时，SDA被拉低（SDA由高变为低），即在SCL处于高状态时，SDA产生一个下降沿；停止位时序：在SCL处于高状态时，SDA在低状态变为高状态（SDA由低变为高），即在SCL处于高状态时，SDA产生一个上升沿 数据阶段时序IIC的数据是先发送高位，数据在传输过程是以bit为单位，在SCL产生的时序脉冲下通过SDA线传输，发送方（可能是主机或从机）每传输1Byte数据需要接收一个应答位，应答位由接收方发出，接收方在接收完1Byte数据，在第九个脉冲产生控制SDA产生应答，用于告诉发送方接下来通信事宜，接收方在第九个脉冲拉低SDA表示应答发送方，拉高SDA表示不应答 数据阶段，SCL处于低状态时，允许SDA改变状态，这时发送方把数据放到SDA上；SCL处于高状态时，SDA不允许改变状态，接收方从SDA上读取数据。从SCL角度理解，当SCL产生下降沿时，发送方传输数据到SDA上，当SCL产生上升沿时，接收方读取SDA上的数据 时钟延展时序时钟延展是IIC协议一个很重要的特点。一个编址的从机设备在接收（或发送）一个字节后可以保持SCL线为低状态，表示它还没有准备好处理更多的数据，正在与它进行通讯的主机可能无法完成当前位的传输，也必须等到SCL实际变为高为止。如果从机发起时钟延展，SCL线必须保持低状态（因为硬件上SCL是开漏输出），同样的，主机必须观察等待SCL线变为高状态 尽管理论上在通信过程的任何一位置都可以使用时钟延展，但是时钟延展通常使用在应答位前/后。例如，如果从机是一个MCU设备，它的IIC接口可以在每个字节后延展时钟，直到软件决定是否发出一个应答/不应答 时钟延展是唯一一次从机驱动SCL线（正常通信中由主机控制SCL）。很多从机不需要时钟延展，因此严格上可以认为SCL是一个没有电路驱动的输入。一些主机，如专门定制的ASICs很多都不支持时钟延展，通常这些设备叫做”两线式接口（two-wire interface）”而不是IIC SDA仲裁时序每个主机监控着总线的START（起始）和STOP（停止）位，当其他主机使得总线忙时不启动通讯。无论如何，两个主机有可能同时启动传输，在这种情况下产生仲裁。当一个主机寻址多个从机时，从机发送模式也能产生仲裁，但是这种情况不常见。与在发出重试之前使用随机回退延迟的协议(如以太网)不同，IIC有一个确定性的仲裁政策，每个发送方都检测SDA线电平并与预期的电平作比较，如果他们不匹配，则发送方失去仲裁并推出协议交互 如果一个发送方设置SDA状态位1（高），另一个发送方将SDA设置为0（低），此时SDA线为地状态。第一个发送方检测到总线的SDA电平与预期的不一样，可以得出另一个节点正在发送，第一个注意到这种情况的节点是仲裁失败的节点：它将停止驱动SDA，如果它是主机，它也停止驱动SCL并等待STOP（停止）信号，然后它可能尝试重新发送整个消息。在此期间，其他节点没有注意到SDA实际的电平与预期的不一样，因此可以继续传输。因为到目前为止，信号完全符合它的预期，没有其他发送方干扰它的信息 如果两个主机发送一个消息到不同的从机，发送较低从机地址的一方总是在地址阶段“赢得”仲裁。一旦两个主机可能发送信息给同一个地址从机，而地址有时涉及多个从机，那么仲裁必须继续进入到数据阶段 仲裁一般很少发生，但是对一些特定的多主机支持是必须的，就像时钟延展一样，不是所有设备都支持仲裁。如果支持，通常会贴上支持“多主机”通信的标签 一个主机可能会因为接收到的消息而失去仲裁，并且必须及时将其角色从主机变为从机，以确认其自己的地址 在极其罕见的情况下，两个主机同时发送相同的消息，双方都认为通信时成功的，但是总计只能识别到一个信息。因此，当一个从机可以被多个主机访问时，从机识别的每一条命令要么是幂等（都一样的意思）的，要么必须保证永远都不会是两个主机同一时间发出（比如，一个命令是由一个主机发出的就不是幂等，当某种互斥机制确保在任何给定的时间只能由一个主机发出的命令也不是幂等） 时序补充说明除了START（起始）信号和STOP（停止）信号，SDA线只在SCL线为低状态时发生改变，传输一个数据位时，先保持SDA线稳定在所需的状态然后拉高SCL。当SCL处于低状态时，发送方（通常指主机）将SDA设置为所需的状态然后释放SCL，（一个小延迟后让值传播）让SCL变为高状态，主机等待SCL线自动变为高。SCL的上升时间有一定的延迟（取决上拉电阻的RC时间常数和总线的寄生电容），或者进入了从机的始终延展。一旦SCL变为高，主机将等待一个最小时间（主机是SCL的发送方），标准IIC速度为4μs，来确保该数据为被发送出去/被从机接收到，然后再次拉低SCL，这就是传输一个数据位的过程 在一个方向上每8个数据位之后，一个应答位由另一个方向发送，发送方和接收方因为这个应答为而交换角色，原本的接收方会发送一个信号”0”作为应答，如果发送的是“1”： （如果是主机发送给从机）从机无法接收数据。没有这样的从机、命令无法解析或不能接收更多的数据 （如果是从机发送给主机）主机希望传输在这个数据之后停止 在SDA线状态在应答位期间发生改变（SCL线不变），SCL总是由主机控制。在应答位之后，SCL拉低，主机接下来可能会做下面三件事之一： 开始传输另一字节数据：发送方设置SDA状态，然后把SCL状态变为高（释放SCL） 发送一个STOP（停止）信号：设置SDA为低，把SCL状态变为高，然后让SDA为高，释放IIC总线 发送一个重复STSRT（起始）信号，设置SDA为高，把SCL状态变为高，拉低SDA。这是重新开始一个IIC总线消息而不是释放总线 软件实现本文的IIC软件实现部分采用STM32F103C8T6学习板作为主机，BM1383AGLV（大气压传感器）作为从机进行通信讲解，主要分析IIC相关部分，实际的传感器通信过程可以参考源码。需要注意的是，STM32F103C8T6的IO口配置开漏输出模式下，可以通过IDR寄存器读取IO口的电平注：本次的例子为单主机&amp;单从机的通信，在多主机或多从机通信中，本例子不适用 起始&amp;停止时序软件实现IIC的起始条件。总线空闲的情况下，SCL与SDA线都因为上拉电阻而处于高电平状态，在SCL处于高电平状态期间，SDA由高电平状态转为低电平状态时，IIC总线上产生一个起始信号，SDA与SCL的数据建立与保持需要一定的时间（根据通讯速度而定），软件实现如下1234567891011121314151617/** * @函数名 IIC_Start * @功 能 IIC起始条件 * @参 数 无 * @返回值 IIC状态 */void IIC_Start(void)&#123; IIC_SDA_HIGH; //拉高SDA线 IIC_Delay(); //延迟 IIC_SCL_HIGH; //拉高SCL线 IIC_Delay(); //延迟，重复起始建立时间，最小4.7μs IIC_SDA_LOW; //SCL为高期间，SDA线由1-&gt;0，产生起始信号 IIC_Delay(); //延迟 IIC_SCL_LOW; //拉低SCL，准备进入数据传输阶段 IIC_Delay(); //延迟&#125; IIC的停止条件。当总线通信数据传输完成后，需要一个停止条件来结束此次的通信，在SCL处于高电平状态期间，SDA由低电平状态转为高电平状态时，IIC总线上产生一个结束信号，SDA与SCL的数据建立与保持需要一定的时间（根据通讯速度而定），软件实现如下1234567891011121314151617/** * @函数名 IIC_Stop * @功 能 IIC停止条件 * @参 数 无 * @返回值 无 */void IIC_Stop(void)&#123; IIC_SCL_LOW; //拉低SCL IIC_Delay(); //延迟 IIC_SDA_LOW; //拉低SDA线 IIC_Delay(); //延迟 IIC_SCL_HIGH; //拉高SCL线 IIC_Delay(); //延迟 IIC_SDA_HIGH; //SCL为高期间，SDA线由0-&gt;1，产生结束信号 IIC_Delay(); //延迟&#125; 注：通讯过程起始信号与结束信号都由通信主机发起 发送时序&amp;应答检测软件实现IIC总线主机发送数据过程中，高位线发送，SDA数据建立在SCL处于低状态，SDA数据保持在SCL处于高状态，SCL低状态（至少保持一定时间）到高状态（至少保持一定时间）为一个脉冲，接收方每接收一字节数据，需要发送一个应答信号给主机12345678910111213141516171819202122232425262728293031323334353637/** * @函数名 IIC_WirteByte * @功 能 IIC写一个字节 * @参 数 无 * @返回值 et_IIC_ERROR：IIC状态 */et_IIC_ERROR IIC_WirteByte(uint8_t TxByte)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR uint8_t mask; //定义变量 for(mask = 0x80; mask &gt; 0; mssk &gt;&gt;= 1) //循环8次传输一字节数据，高位先发送 &#123; if((mask &amp; TxByte) == 0) //根据位状态来控制SDA线 IIC_SDA_LOW; else IIC_SDA_HIGH; IIC_Delay(); //延迟，数据保持稳定需要时间 IIC_SCL_HIGH; //拉高SCL线，传输SDA线上的数据 IIC_Delay(); //延迟，数据保持最少4μs，让接收方有充足时间读取 IIC_SCL_LOW; //拉低SCL，准备下一个bit传输 IIC_Delay(); //延迟，SDA数据建立需要时间 &#125; IIC_SDA_HIGH; //数据传输结束，释放SDA线 IIC_SCL_HIGH; //拉高SCL，产生一个脉冲，读取接收方发送的应答位 IIC_Delay(); //延迟，SDA数据建立需要时间 if(IIC_SDA_READ) //读取SDA应答位，如果SDA = 1，则接收方无应答 error = IIC_NACK_ERROR; IIC_SCL_LOW; //拉低SCL，结束当前写数据通信 IIC_Delay(); //延迟 return error; //返回IIC状态&#125; 注：每次发送完，需要把SCL拉低以避免引起总线时序错误 读取时序&amp;发送应答软件实现IIC总线主机接收数据过程中，SCL线由主机控制产生脉冲进行读取数据，数据高位先读取，需要注意的是，在产生脉冲时SCL线需要一定的延迟来保证SDA上的数据建立完成和保持稳定（软件模拟需要），主机接收完一个字节后需要发送一个应答/不应答信号给从机1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @函数名 IIC_ReadByte * @功 能 IIC读取一个字节 * @参 数 RxByte：存储读取的字节地址；ack：读取后是否发送应答 * @返回值 et_IIC_ERROR：IIC状态 */et_IIC_ERROR IIC_ReadByte(uint8 *RxByte, et_IIC_ACK ack)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR uint8_t mask; //定义变量 *RxByte = 0x00; //初始化RxByte地址上的数据为0x00 IIC_SDA_HIGH; //释放SDA IIC_Delay(); //延迟 for(mask = 0x80; mask &gt; 0; mask &gt;&gt;= 1) //循环8次读取一字节数据，高位先读取 &#123; IIC_SCL_HIGH; //拉高SCL，产生脉冲 IIC_Delay(); //延迟，SDA数据保持 #ifdef IIC_Clock_Stretching //如果IIC从机支持时钟延展，则检测时钟延展 error = IIC_Wait_ClockStreching(); IIC_Delay(); #endif if(IIC_SDA_READ) //读取SDA上的数据位 *RxByte |= mask; IIC_SCL_LOW; //拉低SCL，准备下一bit传输 IIC_Delay(); //延迟，SDA数据建立 &#125; if(ack == IIC_ACK) //如果需要发送应答，拉低SDA线发送应答信号 IIC_SDA_LOW; else //否则拉高SDA线发送不应答信号 IIC_SDA_HIGH; IIC_Delay(); //延迟，SDA数据建立 IIC_SCL_HIGH; //拉高SCL IIC_Delay(); //延迟，SDA数据保持 IIC_SCL_LOW; //读取完毕，拉低SCL线 IIC_SDA_HIGH; //释放SDA线 IIC_Delay(); //延迟 return error; //返回IIC状态&#125; 注：每次发送完，需要把SCL拉低以避免引起总线时序错误 IIC的时钟延展&amp;总线仲裁时序IIC的时钟延展是由从机发起，在通信过程中，从机接收主机发送的命令后，由于还没有准备好数据或通信就会主动拉低SCL来告诉主机，此时主机应该等待SCL释放，当然从机拉低SCL应该由一个时限，不然通信就会一直阻塞在这里，主机也可以设一个超时时限注：不是所有IIC从机都拥有时钟延展特性 1234567891011121314151617181920212223/** * @函数名 IIC_Wait_ClockStreching * @功 能 IIC等待时钟延展 * @参 数 无 * @返回值 IIC状态 */static et_IIC_ERROR IIC_Wait_ClockStreching(void)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR static uint8_t timeout = 100; //定义超时时间100*IIC_Delay()，视实际从机协议而定 while(IIC_SDA_READ == 0) //等待SCL释放 &#123; if((timeout--) == 0) //时钟延展超时 &#123; timeout = 100; //重新赋值 return IIC_TIMEOUT_ERROR; //返回IIC错误状态 &#125; IIC_Delay(); //延迟 &#125; return error; //返回IIC状态&#125; IIC总线上如果存在多个主机，那么可能会出现SDA仲裁。当一个主机正在通信时，另一个主机想要控制IIC总线进行通信就会引发仲裁，SDA仲裁应用在多主机系统总，当一个主机想要发起通信，这时它应该检测SDA线是否在一个时间内处于高状态，如果是，表面IIC系统空闲，否则表面IIC系统中存在通信，系统忙。SDA仲裁比较少见，检测也比较简单 BM1383传感器数据读取BM1383的一些基本的寄存器地址和数据的计算方式等细节可以参考传感器官方手册，这里根据手册提供的IIC时序通信，实现数据的读取，相关读写时序如下图 代码实现读写寄存器如下1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @函数名 BM1383_WriteReg * @功 能 BM1383写寄存器 * @参 数 Reg_Addr：寄存器地址；Reg_Data：写入寄存器的数据 * @返回值 et_IIC_ERROR：IIC通讯状态 */et_IIC_ERROR BM1383_WriteReg(uint8_t Reg_Addr, uint8_t Reg_Data)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR IIC_Start(); //起始信号 error = IIC_WirteByte(BM1383_ADDR + 0); //写从机地址+写模式 error = IIC_WirteByte(Reg_Addr); //写寄存器地址 error = IIC_WirteByte(Reg_Data); //往寄存器写入数据 IIC_Stop(); //停止信号 return error; //返回IIC状态&#125;/** * @函数名 BM1383_ReadReg * @功 能 BM1383读寄存器 * @参 数 Reg_Addr：寄存器地址；*Reg_Data：读出寄存器数据存放的地址 * @返回值 et_IIC_ERROR：IIC通讯状态 */et_IIC_ERROR BM1383_ReadReg(uint8_t Reg_Addr, uint8_t *Reg_Data)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR uint8_t data; IIC_Start(); //起始信号 error = IIC_WirteByte(BM1383_ADDR + 0); //写从机地址+写模式 error = IIC_WirteByte(Reg_Addr); //写寄存器地址 IIC_Start(); //重启IIC总线 error = IIC_WirteByte(BM1383_ADDR + 1); //写从机地址+读模式 error = IIC_ReadByte(&amp;data, IIC_NACK); //读取一个字节+不应答 IIC_Stop(); //停止信号 *Reg_Data = data; //接收读取到的数据 return error; //返回IIC状态&#125; 读取BM1383的ID程序实现如下1234567891011121314151617181920212223242526/** * @函数名 BM1383_ReadID * @功 能 BM1383读ID * @参 数 Reg_Addr：寄存器地址；*ID_Data：存储BM1383的ID地址 * @返回值 et_IIC_ERROR：IIC通讯状态 */et_IIC_ERROR BM1383_ReadID(uint16_t *ID_Data)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR uint8_t bytes[2]; //定义临时数组，存储读取的数据 IIC_Start(); //起始信号 error = IIC_WirteByte(BM1383_ADDR + 0); //写从机地址+写模式 error = IIC_WirteByte(BM1383_ID1); //写寄存器地址 IIC_Start(); //重启IIC总线 error = IIC_WirteByte(BM1383_ADDR + 1); //写从机地址+读模式 error = IIC_ReadByte(&amp;bytes[0], IIC_ACK); //读取第一个字节+应答 error = IIC_ReadByte(&amp;bytes[1], IIC_NACK); //读取第二个字节+不应答 IIC_Stop(); //停止信号 *ID_Data = ((bytes[0] &lt;&lt; 8) | bytes[1]); //合成数据 return error; //返回IIC状态 &#125; 读取BM1383传感器大气压&amp;温度数据程序实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @函数名 BM1383_OneShot_ReadData * @功 能 BM1383读数据,单次模式,时间30ms * @参 数 *My_Data：存储数据地址 * @返回值 et_IIC_ERROR：IIC通讯状态 */et_IIC_ERROR BM1383_OneShot_ReadData(BM1383_Data *My_Data)&#123; et_IIC_ERROR error = IIC_NO_ERROR; //枚举变量记录IIC通信状态，初始为NO_ERROR uint8_t status; //定义临时变量 uint32_t pressure; //定义临时变量 uint16_t temperature; //定义临时变量 error = BM1383_WriteReg(BM1383_PowerDown, 0x01); //BM1383上电 Delay_ms(2); //延迟 error = BM1383_WriteReg(BM1383_Reset, 0x01); //BM1383复位 error = BM1383_WriteReg(BM1383_ModeControl, (0x18 | Time_30_60 | Mode_OneShot)); //配置BM1383，单词测量模式，时间30ms while(DRDY_PORT-&gt;IDR &amp; DRDY_PIN); //等待测量完成 error = BM1383_ReadReg(BM1383_Status, &amp;status); //读取状态寄存器，清除RD_DRDY位 IIC_Start(); //起始信号 error = IIC_WirteByte(BM1383_ADDR + 0); error = IIC_WirteByte(BM1383_PressureMsb); //写从机地址+写模式 IIC_Start(); //重启IIC总线 error = IIC_WirteByte(BM1383_ADDR + 1); //写从机地址+读模式 error = IIC_ReadByte(&amp;My_Data-&gt;PressureMsb, IIC_ACK); //读取第一个字节+应答 error = IIC_ReadByte(&amp;My_Data-&gt;PressureLsb1, IIC_ACK); //读取第二个字节+应答 error = IIC_ReadByte(&amp;My_Data-&gt;PressureLsb2, IIC_ACK); //读取第三个字节+应答 error = IIC_ReadByte(&amp;My_Data-&gt;TemperatureMsb, IIC_ACK); //读取第四个字节+应答 error = IIC_ReadByte(&amp;My_Data-&gt;TemperatureLsb, IIC_NACK); //读取第五个字节+不应答 IIC_Stop(); //停止信号 //合成数据 pressure = My_Data-&gt;PressureMsb; pressure = ((pressure &lt;&lt; 8) | My_Data-&gt;PressureLsb1); pressure = ((pressure &lt;&lt; 6) | (My_Data-&gt;PressureLsb2 &gt;&gt; 2)); My_Data-&gt;Pressure_Value = pressure &gt;&gt; 11; temperature = My_Data-&gt;TemperatureMsb; temperature = (temperature &lt;&lt; 8 | My_Data-&gt;TemperatureLsb); My_Data-&gt;Temperature_Value = temperature &gt;&gt; 5; return error; //返回IIC状态&#125; 最后，在主函数中实现读取BM1383的ID并打印，然后大约每500ms读取一次大气压&amp;温度数据并打印，程序效果如下 BM1383手册下载连接：http://02.xiaolinjun.top/bm1383aglv-e.pdf例程地址：https://github.com/LGG001/MyApplication_Program/tree/master/Sensor]]></content>
      <categories>
        <category>mcu编程类</category>
      </categories>
      <tags>
        <tag>嵌入式硬件通信接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KEIL-MDK安装]]></title>
    <url>%2F2019%2F02%2F17%2FKEIL-MDK%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[软件介绍基本介绍KEIL-MDK是一款针对Cortex-M内核MCU开发的IDE，功能强大，使用简易，能帮助开发者快速开发产品。目前KEIL分为两类，一类为开发C51的KEIL-C51,另一类就是KEIL-MDK。KEIL-MDK主要有两个大版本，一个是MDK4；一个是MDK5；两个版本的主要区别是：MDK4是自带软件包，MDK5需要手动添加/安装，当然还有其它的一些区别，详情可以到KEIL官方查看。本文介绍KEIL-MDK5（兼容MDK4）的下载安装（一些使用MDK4版本建立的工程使用MDK5打开是会出现编译错误，解决方法就是安装对于版本的MDK4兼容版） 应用领域Cortex-M内核MCU有许多公司都有生产出售，比较熟悉的有ST(意法半导体)和NXP（恩智浦半导体），而大多数开发者开发是采用的IDE工具就是KEIL-ARM（也有其他的如IAR-ARM,GCC等等） 软件下载目前MDK5的最新版本是5.26（据官网消息，5.27版本快要出来），下载是要注意是否有对应版本的MDK4兼容包，这里使用的是MDK5.25和对应版本的MDK4安装 官方地址MDK5下载地址：https://www.keil.com/demo/eval/arm.htmMDK4兼容包下载地址： 软件支持包下载地址：http://www.keil.com/dd2/Pack/ 百度网盘链接：https://pan.baidu.com/s/1XJcRmb1H-HgfUtNiKJ_zIA提取码：b06e 软件安装首先安装MDK5.25，双击软件进行安装，一路点击Next即可，如需要填写信息部分可以随便填写，如都填写”abc” 然后安装对于版本的MDK4兼容包，双击软件进行安装，一路点击Next即可 软件破解在百度网盘中有一个“注册机.exe”，该软件是用来对KEIL-MDK进行破解的，首先使用管理员的身份运行MDK软件，然后双击运行注册机.exe（注：杀毒软件可能会将该软件拦截），在KEIL-MDK软件界面中点击File-&gt;License Management,复制CID到注册机软件，选择Target为ARM，点击Geberate即可生成注册码 把生成的注册码复制到License Management中的New Lincense ID Code(LIC),点击Add LIC即可完成破解 注：只供学习使用，推荐支持正版 软件配置软件的一些编辑界面配置位于Edit-&gt;Configuration，可以配置编码、字体大小、窗口颜色等等，这些可以根据自己喜好来进行配置]]></content>
      <categories>
        <category>软件安装类</category>
      </categories>
      <tags>
        <tag>KEIL-MDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad2下载&安装]]></title>
    <url>%2F2019%2F01%2F14%2Fmarkdownpad2%E4%B8%8B%E8%BD%BD-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[软件介绍基本介绍Markdownpad2是一款windows平台下的markdown编辑器，它界面精简功能强大，在编辑的同时能实时预览 应用领域目前许多论坛和博客都采用markdown的格式发帖，markdown格式是一种简单优雅的文本编辑模式，非常适合用于编辑文档或者发表文章使用，比如国外著名的开源网站github就是使用markdown格式文本 软件下载再安装markdownpad2前需要下载安装awesomium_v1.6.6_sdk_win（用于渲染html，实现预览效果） 官方地址点击下载：awesomium_v1.6.6_sdk_win 点击下载：markdownpad2 百度网盘链接：https://pan.baidu.com/s/13RuM4hvkK9bwzKYelGBaYQ提取码：y7ez 软件安装首先安装awesomium_v1.6.6_sdk_win，双击安装，一路Next即可 然后安装markdownpad2，双击安装，一路Next即可 软件破解12Email address :Soar360@live.comLicense key：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 软件配置安装完成后，可以根据个人风格对markdownpad2进行配置，点击菜单栏Tools–&gt;Options，在Editor定义字体大小，软件语言（可以为中文） markdown语法建议使用github离线版，配置如下 样式表配置如下 在高级选项里可以进行脚本配置，这里实现代码高亮，输出目录，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot;&gt;&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;Cache&quot; content=&quot;no-cache&quot;&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/vs.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js&quot;&gt;&lt;/script&gt; &lt;script &gt;hljs.initHighlightingOnLoad();&lt;/script&gt; &lt;link href=&quot;https://cdn.bootcss.com/jquery.tocify/1.9.0/stylesheets/jquery.tocify.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.8.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/jqueryui/1.10.1/jquery-ui.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js&quot;&gt;&lt;/script&gt;&lt;style&gt;.tocCal&#123; position: fixed; width: 400px; max-width: 450px; margin: 0px 0px 20px 0px; top: 36px; right:30px; font-size: 13px; max-height:90%; background-color: #0088CC; border: 1px solid #ccc; webkit-border-radius: 6px; moz-border-radius: 6px; border-radius: 6px; color: white;&#125;.toc &#123; position: fixed; width: 400px; max-width: 450px; margin: 0px 0px 20px 0px; top: 60px; right:30px; /*background: #f1f1f1;*/ background-color: #ffffff; font-size: 13px; max-height:86%; border: 1px solid #ccc; webkit-border-radius: 6px; moz-border-radius: 6px; border-radius: 6px;&#125;.nav-list &gt; .active &gt; a, .nav-list &gt; .active &gt; a:hover &#123; color: #ffffff; text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.2); background-color: #0088cc;&#125;&lt;/style&gt;&lt;script&gt;function muluShow()&#123; var visibleFlag=$(&quot;#toc&quot;).is(&quot;:visible&quot;); if(visibleFlag)&#123; $(&quot;#toc&quot;).hide(); $(&quot;#mulu_tt&quot;).text(&quot;▼&quot;); $(&quot;#tocCal&quot;).css(&quot;width&quot;,&quot;100px&quot;); &#125;else&#123; $(&quot;#toc&quot;).show(); $(&quot;#mulu_tt&quot;).text(&quot;▲&quot;); $(&quot;#tocCal&quot;).css(&quot;width&quot;,&quot;&quot;); &#125;&#125;$(function() &#123; $(&quot;body&quot;).append(&apos;&lt;div id=&quot;tocCal&quot; class=&quot;tocCal&quot; &gt;&lt;div id=&quot;mulu&quot;&gt;&lt;span style=&quot;right:0px;float: right; padding-right: 33px;cursor:pointer;&quot; onclick=&quot;muluShow()&quot;&gt; &lt;span&gt;目录&lt;/span&gt;&lt;span id=&quot;mulu_tt&quot;&gt;▲&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;toc&quot; class=&quot;toc&quot; &gt;&lt;/div&gt;&lt;/div&gt;&apos;); var toc = $(&quot;#toc&quot;).tocify(&#123; selectors:&quot;h1,h2,h3,h4,h5,h6&quot;, extendPage:false &#125;).data(&quot;toc-tocify&quot;); muluShow(); //刚打开页面时，目录是缩小的。 &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>软件安装类</category>
      </categories>
      <tags>
        <tag>markdownpad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按键长短按检测]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%8C%89%E9%94%AE%E9%95%BF%E7%9F%AD%E6%8C%89%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[环境介绍软件环境介绍PC环境：Windows10 64-bitIDE环境：MDK-ARM 5.24.2.0工程名称：STM32_KeyTest工程下载地址：github 硬件环境介绍MCU平台：STM32F103C8T6工程名称：STM32 Display Board V1.0工程下载地址：github 应用环境介绍按键检测是属于一个基础的单片机IO口应用，在消费级产品中如：洗衣机、抽油烟机、MP3…等等，几乎任何一个产品都会带有按键，因此在研发人员开发中就会遇到检测按键功能设计，本文从硬件原理到软件实现介绍如何检测按键的长短按，并触发相应的事件，可以轻松移植到任何MCU平台上。硬件平台使用的是以STM32F103C8T6位核心的一块STM32 Display Board V1.0开发板，开源在github上，可通过上面相应链接进行下载。软件工程也开源在github上可通过上面相应链接进行下载 原理介绍硬件过程分析按键电路一般是：一端接上拉电阻（IO口带上拉电阻配置可直接配置），一点接GND，当按键没有按下时位高电平，按下位低电平。按键在实际工作中会存在许多的干扰，如在按下的一瞬间会有抖动、误触发等。因为按键本身的特性原因，在按下的时候会有一个抖动电平，这个抖动会触发多个高低电平，因此会使按键无法正常直接检测。 状态与时间分析 本文章讨论按键长短按，上图就是一个按键长短按的整一个过程，在这个过程中可以把按键划分为如下几个状态： A：IDLE-空闲状态，没有按键按下或按键释放后的状态 B：Debounce-消抖状态，按键按下瞬间的抖动状态 C：Pressed-按键按下状态，为低电平 D：Long_Pressed-按键长按状态，按键按下超过一定的时间 E：Release-按键释放状态，按键松开的状态 按键的触发过程是一个从左向右的单向过程，在这每个过程都对应着一个时间段，不过在检测长短按过程中只需重点要关注B：消抖时间、D：长按时间、E：释放时间 其他状态时间A：空闲状态时间、C：按键按下的时间可以有B、D、E的时间以及状态确定 在按键过程分析中，主要分析下图的三个过程： 按键消抖过程（或误触发） 按键短按过程 按键长按过程 程序设计数据结构定义数据结构的定义位于button.h文件。从上面的分析可以知道，在按键长短按过程中主要涉及五个状态与三个重要时间段，因为在一个时间段内只能存在一种状态，程序中可以把状态定义为枚举类型：12345678typedef enum&#123; IDLE, //空闲 Debounce, //消抖 Pressed, //按下 Long_Pressed, //长按 Release, //释放&#125;key_status; //按键状态 同时使用结构体类型定义按键长短按的时间变量：123456typedef struct&#123; unsigned int Time_Debounce; //消抖时间 unsigned int Time_LongPressed; //长按时间 unsigned int Time_Release; //释放时间&#125;key_time; //消抖、长按&amp;释放时间 硬件上有六个按键，每一个按键都有长按短按两种情况，应为一次只能检测一个按键的长短按，所以使用枚举的方式定义KEY1~KEY6的长短按键值：12345678910111213141516typedef enum&#123; NULL_Pressed=0, //无按键按下 KEY1_Pressed, //KEY1按下（短按） KEY2_Pressed, //KEY2按下（短按） KEY3_Pressed, //KEY3按下（短按） KEY4_Pressed, //KEY4按下（短按） KEY5_Pressed, //KEY5按下（短按） KEY6_Pressed, //KEY6按下（短按） KEY1_LongPressed, //KEY1长按 KEY2_LongPressed, //KEY2长按 KEY3_LongPressed, //KEY3长按 KEY4_LongPressed, //KEY4长按 KEY5_LongPressed, //KEY5长按 KEY6_LongPressed, //KEY6长按&#125;key_value; //键值 为了能方便的找到是哪个按键处于那个状态，还是短按（或长按），可以定义一个键表，方便在扫描过程中找对对应按键：12345678typedef struct&#123; unsigned int Index; //按键索引(按键按下的键值) key_value Value1; //键值1（KEYx按下） key_value Value2; //键值2（KEYx长按） key_status State1; //按键状态1（按下状态） key_status State2; //按键状态2（长按状态）&#125;KEY_Table; 索引值指的是按键按下时对应的值，硬件中KEY1~KEY6都使用PB上的IO口，每个按键按下的键值（十六进制）都不一样，使用宏定义：1234567#define KEY_VALUE 0x3c03 //没按键按下的键值#define KEY1_VALUE 0x3c02 //KEY1按下的键值#define KEY2_VALUE 0x3c01 //KEY2按下的键值#define KEY3_VALUE 0x3803 //KEY3按下的键值#define KEY4_VALUE 0x3403 //KEY4按下的键值#define KEY5_VALUE 0x2c03 //KEY5按下的键值#define KEY6_VALUE 0x1c03 //KEY6按下的键值 时间参数一般消抖采用50ms，释放3ms，长按2s，按键的检测周期位10ms，对应时间可以使用宏定义：123#define RELEASE_TIMES 3 //按键释放时间#define DEBOUNCE_TIMES 5 //按键消抖时间#define LONG_PRESSED_TIMES 200 //按键长按时间 按键扫描过程程序设计按键扫描过程程序位于button.c文件。在扫描前先定义一个键值表存放每个按键的索引、键值、状态：12345678910//键值表const KEY_Table key_tab[]=&#123; &#123;KEY1_VALUE, KEY1_Pressed, KEY1_LongPressed, Pressed, Long_Pressed&#125;, //KEY1-短按-长按 &#123;KEY2_VALUE, KEY2_Pressed, KEY2_LongPressed, Pressed, Long_Pressed&#125;, //KEY2-短按-长按 &#123;KEY3_VALUE, KEY3_Pressed, KEY3_LongPressed, Pressed, Long_Pressed&#125;, //KEY3-短按-长按 &#123;KEY4_VALUE, KEY4_Pressed, KEY4_LongPressed, Pressed, Long_Pressed&#125;, //KEY4-短按-长按 &#123;KEY5_VALUE, KEY5_Pressed, KEY5_LongPressed, Pressed, Long_Pressed&#125;, //KEY5-短按-长按 &#123;KEY6_VALUE, KEY6_Pressed, KEY6_LongPressed, Pressed, Long_Pressed&#125;, //KEY6-短按-长按&#125;; 按键扫描过程： 读取键值，如果有按键按下则赋值释放时间，然后判断上一次的状态 如果为空闲则证明按键第一次按下，赋值消抖时间并把状态改为消抖 如果在消抖状态并消抖完成，赋值长按时间并在键值表中找出对应的键值，把状态改为按下；如果没有找到则判断为误触发或多按键同时按下 如果在按下状态并检测到长按时间完成，在键值表中找出对应的键值，把状态改为长按；如果没有找到则判断为误触发或多按键同时按下 如过在长按状态下则不处理 其他情况把状态改为空闲并退出 读取键值后，发现是没有按键按下，则贩毒案释放时间是否完成，如果完成则判断状态 如果为按下状态，则找出对应按键并返回它的值（按下） 如果为长按状态，则找出对应按键并返回它的值（长按） 其他状态，如空闲、消抖等等；把状态置为空闲后退出注：按键短按长按要在释放后才有效；函数中有多处是使用static修饰的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * @函数名 check_user_key * @功 能 按键扫描 * @参 数 无 * @返回值 key_value：键值 */key_value KEY_Scan(void)&#123; static key_status state; //按键状态 static key_time time; //按键消抖和释放的时间 volatile key_value KEY_Value = NULL_Pressed; //键值，初始为空 static unsigned char i; //扫描键值表计数：i unsigned int key_temp; key_temp = (GPIO_ReadInputData(GPIOB) &amp; KEY_VALUE); //读取键值 if(key_temp != KEY_VALUE) //判断是否有按键按下 &#123; time.Time_Release = RELEASE_TIMES; //有按键按下（在按下的状态），赋值释放时间 switch(state) //判断上一次按键的状态 &#123; case IDLE: //空闲状态 time.Time_Debounce = DEBOUNCE_TIMES; //赋值消抖时间 state = Debounce; //将状态改为消抖状态 break; //退出 case Debounce: //消抖状态 if(--time.Time_Debounce == 0) //消抖完成 &#123; time.Time_LongPressed = LONG_PRESSED_TIMES; //长按的时间赋值 for(i=0; ;i++) //循环查询键值表 &#123; if(key_temp == key_tab[i].Index) //循环查询索引 &#123; state = key_tab[i].State1; //对应索引的状态为按下（PRESSED） break; //退出循环 &#125; else if(i &gt;= 6) //超出按键扫描范围，或同时按到其他按键 &#123; state=IDLE; //把状态重新配置为空闲 return NULL_Pressed; //返回空值 &#125; &#125; &#125; break; case Pressed: //按键按下状态 if(--time.Time_LongPressed == 0) //长按消抖完成 &#123; for(i=0; ;i++) //循环查询键值表 &#123; if(key_temp == key_tab[i].Index) //重新循环查询索引 &#123; state = key_tab[i].State2; //对应索引的状态为长按（LONG_PRESSED） break; //退出循环 &#125; else if(i &gt; 6) //超出按键扫描范围，或同时按到其他按键 &#123; state=IDLE; //把状态重新配置为空闲 return NULL_Pressed; //返回空值 &#125; &#125; &#125; break; case Long_Pressed: //一直保持长按，退出，不处理 break; default: //其他情况，将状态设为空闲，退出 state=IDLE; break; &#125; &#125; else &#123; if(time.Time_Release != 0) //判断按键是否已经释放完成（空闲状态时stkey.release一直等于0） &#123; if(--time.Time_Release == 0) //如果按键已经释放 &#123; switch(state) &#123; case Pressed: //按键按下，返回单击键值 KEY_Value=key_tab[i].Value1; state=IDLE; //将状态设为空闲 break; case Long_Pressed: //按键长按，返回按键长按键值 KEY_Value=key_tab[i].Value2; state=IDLE; //将状态设为空闲 break; default: //其他情况（消抖期间释放，或一直没按键按下），将状态设为空闲，退出 state=IDLE; break; &#125; &#125; &#125; &#125; return KEY_Value; //返回键值&#125; 键值处理过程程序设计键值处理过程程序位于button.c文件。将上面获取的键值，根据不同的键值进行不同的处理，需要注意的是：程序中使用窗口打印信息，一般不建议在处理函数中做复杂的处理，这会影响程序运行的时间，这里主要作为演示效果使用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @函数名 KeyProcess * @功 能 按键处理，根据键值来执行相应的操作 * @参 数 key_val：键值 * @返回值 无 */void KEY_Process(key_value key_value)&#123; switch(key_value) &#123; case KEY1_Pressed: //KEY1按下（短按） printf("KEY1_Pressed! \r\n"); //打印信息 break; case KEY2_Pressed: //KEY2按下（短按） printf("KEY2_Pressed! \r\n"); //打印信息 break; case KEY3_Pressed: //KEY3按下（短按） printf("KEY3_Pressed! \r\n"); //打印信息 break; case KEY4_Pressed: //KEY4按下（短按） printf("KEY4_Pressed! \r\n"); //打印信息 break; case KEY5_Pressed: //KEY5按下（短按） printf("KEY5_Pressed! \r\n"); //打印信息 break; case KEY6_Pressed: //KEY6按下（短按） printf("KEY6_Pressed! \r\n"); //打印信息 break; case KEY1_LongPressed: //KEY1长按 printf("KEY1_LongPressed! \r\n"); //打印信息 break; case KEY2_LongPressed: //KEY2长按 printf("KEY2_LongPressed! \r\n"); //打印信息 break; case KEY3_LongPressed: //KEY3长按 printf("KEY3_LongPressed! \r\n"); //打印信息 break; case KEY4_LongPressed: //KEY4长按 printf("KEY4_LongPressed! \r\n"); //打印信息 break; case KEY5_LongPressed: //KEY5长按 printf("KEY5_LongPressed! \r\n"); //打印信息 break; case KEY6_LongPressed: //KEY6长按 printf("KEY6_LongPressed! \r\n"); //打印信息 break; default: //其他 break; &#125;&#125; 主函数处理在初始化好相应的接口后，只需要提供10ms作为按键扫描的时基，如下：123456789101112131415161718192021222324252627/** * @函数名 main * @功 能 主函数入口 * @参 数 无 * @返回值 无 */int main(void)&#123; key_value temp; //键值变量 LED_Init(); //LED初始化 KEY_Init(); //KEY初始化 USART1_Init(); //串口初始化 Delay_Init(); //延迟初始化 GPIO_ResetBits(LED1_PORT,LED1_PIN); //LED1亮 GPIO_ResetBits(LED2_PORT,LED2_PIN); //LED2亮 while(1) &#123; temp = KEY_Scan(); //获取键值 if(temp != NULL_Pressed) //如果键值非空（有按键按下） KEY_Process(temp); //处理键值 Delay_ms(10); //时间单位10ms &#125;&#125; 实现效果使用USB转TTL把串口链接PC，打开上位机（这里使用的是SecureCRT 8.3，其他的串口助手也一样），配置波特率115200、停止位1位，数据位8位，无奇偶校验，无流控。效果中首先短按KEY1、KEY3，然后长按KEY2、KEY4：]]></content>
      <categories>
        <category>mcu编程类</category>
      </categories>
      <tags>
        <tag>MCU程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime的C/C++环境配置]]></title>
    <url>%2F2018%2F10%2F15%2Fsublime%E7%9A%84C%26C%2B%2B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[sublime的C/C++环境配置sublime text3的代码编辑功能非常强大好用，不仅界面好看，还有丰富的插件可供选择。个人常用sublime text3进行代码编辑和查看，经常会接触C/C++算法，希望能在其上面进行编译从而看到结果，方便学习 环境PC环境：Windows10 64bitIDE：sublime text3其他：MinGw MinGw安装要在sublime text3运行C/C++，首先需要安装gcc环境，这里安装MinGw，关于其左右可以自行百度，下载和安装参考下方链接： 下载地址安装教程 注：如上链接下载不了，可点击此下载地址链接进行下载 下载完双击进行安装，安装完成后配置环境变量： 配置完成后，打开命令行输入g++ -v，如下即为配置成功 sublime text3配置打开sublime，点击Tools→Build System→New Build System，将里面的代码都删除，粘贴以下代码：123456789101112131415161718&#123;&quot;cmd&quot;: [&quot;g++&quot;,&quot;-Wall&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;],&quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,&quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,&quot;selector&quot;: &quot;source.c, source.c++&quot;,&quot;encoding&quot;:&quot;cp936&quot;,&quot;variants&quot;:[&#123;&quot;name&quot;: &quot;Run&quot;,&quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;-Wall&quot;,&quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;]&#125;,&#123;&quot;name&quot;: &quot;RunInCommand&quot;,&quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;-Wall&quot;,&quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; echo.&amp;pause&quot;]&#125;]&#125; 最后Ctrl+S保存文件在默认路径，命名为c，至此配置完成 新建一个test.c文件，往里输入内容123456789#include &lt;stdio.h&gt;int main()&#123; int a = 5; int b = 10; printf(&quot;a = %d, b = %d\n&quot;, a,b);&#125; 文件内容书写完毕后先保存，然后点击Tools–&gt;Build With…，选择c-RunInCommand，在命令行运行C代码并再执行输出，效果如下 为了更方便执行，这里配置一个快捷键F9来代替（Tools–&gt;Build With…–&gt;c-RunInCommand）运行操作；点击Perferences→Key Bindings - User，将里面的代码都删除，粘贴以下代码： 123[&#123;&quot;keys&quot;: [&quot;f9&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123;&quot;variant&quot;: &quot;RunInCommand&quot;&#125;&#125;] 输入完毕后Ctrl+S直接保存，后面运行是直接按F9即可 注：如果运行的代码错误会显示错误，并且不会打开命令行]]></content>
      <categories>
        <category>软件安装类</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime下载&安装]]></title>
    <url>%2F2018%2F10%2F15%2Fsublime%E4%B8%8B%E8%BD%BD%26%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[sublime下载&amp;安装 注：该文只供学习参考 环境PC环境：Windows10 64bitIDE：sublime text3 下载目前最新版本为sublime text3，根据目标选择对应版本，下载地址：https://www.sublimetext.com/3 安装sublime text3安装比较简单，一直点击next即可。 安装完成后，需要注册码（Help–&gt;Enter License），可在网上搜索得到，这里从网上下载一些共参考：12345678910111213—– BEGIN LICENSE —– Country Rebel Single User License EA7E-993095 19176BCE 3FF86EA0 3CE86508 6BE4DCA7 9F74D761 4D0CAD8B E4033008 43FC73F3 1C01F6DD C4829BE9 E7830578 A4823ADC 61B224F1 DC93C458 ABAAAE0F 925C32D4 04A83C36 813FF6C8 9877942C 4418F99C 2F15E5B8 544EDB80 D9A86985 4CBBA6A8 998DE3E4 7FB33E15 6CD30357 6DC96CEA ECB1BC4E D8010D5A 77BA86C8 BA7F76CC —— END LICENSE —— 12345678910111213—– BEGIN LICENSE —– TwitterInc 200 User License EA7E-890007 1D77F72E 390CDD93 4DCBA022 FAF60790 61AA12C0 A37081C5 D0316412 4584D136 94D7F7D4 95BC8C1C 527DA828 560BB037 D1EDDD8C AE7B379F 50C9D69D B35179EF 2FE898C4 8E4277A8 555CE714 E1FB0E43 D5D52613 C3D12E98 BC49967F 7652EED2 9D2D2E61 67610860 6D338B72 5CF95C69 E36B85CC 84991F19 7575D828 470A92AB —— END LICENSE —— 12345678910111213—– BEGIN LICENSE —– Bug7sec Team (www.bug7sec.org) 50 User License EA7E-1068832 86C49532 8F829C68 2ED18D56 162664F2 8B934F0C EB60A7FE 81D7D5EF BB8F1673 F67D69C7 C5E21B19 42E7EFBD D9C2BBC1 CEBA4697 535E29CA 0D2D0D4D ACE548CE 07815DC7 BDE3901E D5D198E4 BC1677C0 46097A55 29BCE0C9 72A358E8 CEFEEFB5 24CEB623 D7232749 F2515349 FB675F93 C55635A7 B1E32AB0 3D055979 041E0359 —— END LICENSE —— 12345678910111213—– BEGIN LICENSE —– Esri, Inc 19 User License EA7E-853424 BBB0D927 00F6E4AB 0AFFEFEA 82C4A3E5 4F9A99D1 7C0475AB 5A708861 6C81D74E 4BBA1F56 877CE0E2 88126328 486D8600 8A0A85D7 49671882 49969D92 312F27A7 5CCAE55B D711D4E2 9069DE55 B510370C 9499567E 61D548BA FB260403 711DFE24 1BAFDA6D 1F52E6B1 B728EF5B A40CCD4D FD716AF5 1760D208 0E05F26E 22660950 —— END LICENSE —— 12345678910111213—– BEGIN LICENSE —– Die Socialisten GmbH 10 User License EA7E-800613 51311422 E45F49ED 3F0ADE0C E5B8A508 2F4D9B65 64E1E244 EDA11F0E F9D06110 B7B2E826 E6FDAA72 2C653693 5D80582F 09DCFFB5 113A940C 5045C0CD 5F8332F8 34356CC6 D96F6FDB 4DEC20EA 0A24D83A 2C82C329 E3290B29 A16109A7 EC198EB9 F28EBB17 9C07403F D44BA75A C23C6874 EBF11238 5546C3DD 737DC616 445C2941 —— END LICENSE —— 12345678910111213—– BEGIN LICENSE —– Dylan Tittel Single User License EA7E-898127 CD1A23C0 E8687245 18A89BFA 7CF52C10 A20AA536 9E1A57C7 D33839DC 6613C428 91E9C7FF F4702893 251C6403 27A10818 6F48AC9C BB66843D C1D60DEA B952C2D0 40019115 E5278B04 95EBB709 D6B1C5B9 67CA940A 88701851 32910570 57AD5B96 263A8906 AFBFAB46 52F6706F CACFC74E DFAD4752 D10E58B6 744B90F2 13AF2B9C —— END LICENSE ——]]></content>
      <categories>
        <category>软件安装类</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言算法-排序]]></title>
    <url>%2F2018%2F10%2F14%2FC%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C语言算法-排序 环境PC环境：Windows10 64bitIDE：sublime text3 注：sublime text3需要安装C/C++编译环境处理 选择排序特点：简单、容易实现缺点：执行速度慢 实现过程：通过遍历的方式进行比较，找出数据中最小的（或最大的）放到起始位置，然后起始位置向前加1，再从剩下的找出最小的，以此类推 C语言实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define key(A) (A)#define less(A, B) (key(A) &lt; key(B))#define exch(A, B) &#123;int t = A; A = B; B = t;&#125;#define compexch(A, B) if(less(B, A)) exch(A, B)int array[10] = &#123;5, 9, 0, 1, 3, 6, 8, 7, 2, 4&#125;;void selection_sort(int a[], int count)&#123; int i, j, min; for (i = 0; i &lt; count; i++) &#123; min = i; for (j = i+1; j &lt; count; j++) &#123; if (a[min] &gt; a[j]) min = j; //找到最小的(数组下标) &#125; if (min != i) &#123; compexch(a[i], a[min]); &#125; &#125;&#125;int main() &#123; int i; int count = sizeof(array)/sizeof(array[0]); selection_sort(array, count); for (i = 0; i &lt; count; i++) &#123; printf("%d ", array[i]); &#125; return 0; &#125; 代码分析：123less-比较两个关键字exch-交换两个元素compexch-比较两个元素，并使第一个元素始终为最小 实现效果： 冒泡排序特点：简单、容易实现缺点：执行速度慢 实现过程：通过遍历的方式进行比较，把数据从小到大或从大到小进行排序；假如有十个数据：Array = {3，2，5，8，2，7，0，1，4，6}，首先将第一个数据Array[0]逐次跟后面数据进行比较从而得到10个数据中的最小数（或最大数），同理，Array[1]逐次跟后面数据进行比较从而得到9个数据中的最小数（或最大数）；10个数据需要比较（9+8+7+6+5+4+3+2+1）次才能完成排序，如有N个数则需要比较：N*(N-1)/2，时间复杂度为0(N^2) C语言实现如下：12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define key(A) (A)#define less(A, B) (key(A) &lt; key(B))#define exch(A, B) &#123;int t = A; A = B; B = t;&#125;#define compexch(A, B) if(less(B, A)) exch(A, B)int array[10] = &#123;5, 9, 0, 1, 3, 6, 8, 7, 2, 4&#125;;void bubble_sort(int a[], int count)&#123; int i, j; for (i = 0; i &lt; count; i++) &#123; for (j = i+1; j &lt; count; j++) &#123; compexch(a[i], a[j]); &#125; &#125;&#125;int main() &#123; int i; int count = sizeof(array)/sizeof(array[0]); bubble_sort(array, count); for (i = 0; i &lt; count; i++) &#123; printf("%d ", array[i]); &#125; return 0; &#125; 代码分析：123less-比较两个关键字exch-交换两个元素compexch-比较两个元素，并使第一个元素始终为最小 实现效果： 快速排序特点：执行速度快缺点：使用递归，消耗堆栈空间 实现过程：以一个元素为基准（通常是首元素），然后进行分区（比基准小得数放到左边，大的数放到右边；或反之），同样的方法对左边和右边进行分区，这里使用递归方法即可，以此下次进行排序，平均时间复杂度为O(NlgN) C语言实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int a[] = &#123;6,1,7,5,2,3,9,8,0,4&#125;;void quickSort(int *a, int left, int right)&#123; /*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/ if (left &gt;= right) &#123; return; &#125; int i = left; int j = right; int key = a[left]; /*控制在当组内寻找一遍*/ while (i &lt; j) &#123; /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升 序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ while ((i&lt;j) &amp;&amp; (key&lt;=a[j])) &#123; j--; /*向前寻找*/ &#125; /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是 a[left]，那么就是给key）*/ a[i] = a[j]; /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反， 因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/ while ((i&lt;j) &amp;&amp; (key&gt;=a[i])) &#123; i++; &#125; a[j] = a[i]; &#125; /*当在当组内找完一遍以后就把中间数key回归*/ a[i] = key; /*最后用同样的方式对分出来的左边的小组进行同上的做法*/ quickSort(a, left, i-1); /*用同样的方式对分出来的右边的小组进行同上的做法*/ /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/ quickSort(a, i+1, right);&#125;int main()&#123; quickSort(a, 0, 9); for (int i = 0; i &lt; 10; ++i) &#123; printf("%d ", a[i]); &#125; return 0;&#125; 代码分析：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=a[0]； 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5）重复第3、4步，直到i=j；(3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束），并把基数放到i==j时的A[i]处，实现左边的数比基数小，右边的数比基数大 123456789101112131415161718192021222324252627以一个简单的数组为例：int a[] = &#123;5,8,7,2,4&#125;;代入上代码中运行，i = 0, j = 4, key = 5| 0 | 1 | 2 | 3 | 4 || - | - | - | - | - || 5 | 8 | 7 | 2 | 4 |经个第1次排序后，i = 1, j = 4, key = 5| 0 | 1 | 2 | 3 | 4 || - | - | - | - | - || 4 | 8 | 7 | 2 | 8 |经个第2次排序后，i = 2, j = 3, key = 5| 0 | 1 | 2 | 3 | 4 || - | - | - | - | - || 4 | 2 | 7 | 7 | 8 |经个第3次排序后，i = 2, j = 2, key = 5| 0 | 1 | 2 | 3 | 4 || - | - | - | - | - || 4 | 2 | 5 | 7 | 8 |此时i == j，将key赋值a[i]，a[i] = 5可以看出基数左边的数比基数小，右边的数比基数大此时把左边和右边的数也按照上述步骤进行（使用递归），即可实现快速排序 实现效果： 源码下载 选择排序：http://03.xiaolinjun.top/Selection_Sort.c 冒泡排序：http://03.xiaolinjun.top/Bubble_Sort.c 快速排序：http://03.xiaolinjun.top/Quick_Sort.c]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[osc802测评]]></title>
    <url>%2F2018%2F10%2F03%2Fosc802%E6%B5%8B%E8%AF%84%2F</url>
    <content type="text"><![CDATA[OSC802虚拟示波器简介虚拟示波器优缺点 优点： 体积小，方便使用以及携带，可给每个研发人员独立配备一台 价格便宜，适合示波器入门使用 使用简单方便，操作门槛低 缺点： 功能不及经典示波器（但检测常见信号如PWM,IIC等足够） 检测精度、带宽等会稍逊经典示波器（体积与性能不能兼得） OSC802虚拟示波器参数OSC802虚拟示波器概要： OSC802虚拟示波器硬件参数： OSC802虚拟示波器功能描述： OSC802虚拟示波器线路图： OSC802虚拟示波器购买链接 OSC802-淘宝链接 P2060-淘宝链接 OSC802虚拟示波器环境配置环境介绍PC环境：Windows10 64-bit硬件：OSC802 + P2200（200MHz）探头软件：上位机 + 驱动（Win10自带WinUSB驱动，插入自动安装） 根据PC环境下载相应的资料： 驱动：百度云地址-https://pan.baidu.com/s/1Ko73TxTDd-X7QChnK8DQ1Q，版本-V1.0.0.2 用户手册：百度云地址-https://pan.baidu.com/s/1HkkSBkhe0nOw3ZajX-mfKA，版本-v2.0.0.0 上位机：版本-v2.0.0.0 Windows XP-https://pan.baidu.com/s/1PU6Swqoj4DUk7s4JQ-bl8Q Windows 7-https://pan.baidu.com/s/1ne_kYYMDwh-C7z5W75HM-g Windows 8-https://pan.baidu.com/s/15ZOeJS5Etfj_Gg9DfzMXEQ Windows 10-https://pan.baidu.com/s/1IKXUonht_Vy6UC-vmwD0KA 环境搭建本机环境为Windows10 64-bit，所以不需要安装OSC802虚拟示波器驱动，只需要安装对应环境的上位机即可，下面介绍OSC802上位机安装。 下载对应的上位机软件，解压后双击安装，一路点击NEXT即可安装完成 OSC802虚拟示波器使用硬件链接 使用连接线通过USB连接OSC802与PC—[A] 将示波器探头接入OSC802的CHA，探头检测端接OSC802信号（1kHz，1.5V）输出-B—[B] 将衰减比配置为1X（条件红色部分，打到1X端）—[C]注：由于检测的是OSC802内部输出的信号，所以不需要接地；当检测其他外部信号时需要接地，并确保外部地的电位与PC端地电位一致 信号检测 打开OSC802上位机软件（安装完成后在桌面会生成一个Shortcut to OSC802.exe快捷方式） 打开通道A（关闭通道B），选择捕获模式为Normal，点击右下角的Start Dervice开始检测 调节通道A电压刻度为：1V；调节时间刻度为1ms 设置通道A为上升沿触发，调节触发点 左下角会有通道A检测的信号相关信息 信号分析捕捉到信号后，点击右下角的Stop Dervice暂停检测，通过左下角的数据来分析信号 信号峰值电压 = P_P = 1.543V 信号频率 = Frequency/1ms(0.001) = 995Hz 占空比 ≈ +Wideth / (+Wideth + -Wideth) ≈ %50 其他功能介绍其他的功能使用可以参考官方的用户手册，工具类的学习以多用手实践为主用户手册下载地址：百度云地址-https://pan.baidu.com/s/1HkkSBkhe0nOw3ZajX-mfKA，版本-v2.0.0.0 建议 上位机软件不能随意缩放，只有一个最大化和最小化状态 在最小化视图中，点击FFT图标后，FFT图标会被遮挡住]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>测评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-sorted排序应用]]></title>
    <url>%2F2018%2F10%2F02%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-sorted%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python开发入门-sorted排序应用 Python对数据进行排序有许多种方法，本文主要讨论Python的sorted函数（该函数为Python的内建函数），介绍sorted的功能 环境介绍PC环境：Windows10 64bitPython版本：Python3.6（IDLE） sorted介绍sorted用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大。在python的IDLE环境中输入help(sorted)，可以看到一下描述12345678&gt;&gt;&gt; help(sorted)Help on built-in function sorted in module builtins:sorted(iterable, /, *, key=None, reverse=False) Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. 升降排序一般情况下sorted函数将列表按升序进行排序，并返回一个新列表对象，原列表保持不变123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums)[1, 2, 3, 4, 5] 如果要按照降序排列，只需指定参数 reverse=True 即可 123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums, reverse=True)[5, 4, 3, 2, 1] 指定参数key排序按照某个规则排序，则需指定参数 key，key 是一个函数对象，例如字符串构成的列表，我想按照字符串的长度来排序 123&gt;&gt;&gt; chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']&gt;&gt;&gt; sorted(chars, key=len)['a', 'is', 'from', 'test', 'This', 'Andrew', 'string']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python应用-Excel图表制作]]></title>
    <url>%2F2018%2F09%2F29%2FPython%E5%BA%94%E7%94%A8-Excel%E5%9B%BE%E8%A1%A8%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python应用-Excel图表制作 在实际应用过程中会经常使用excel工具来处理一些数据，或者让里面的数据可视化（图标形式），如果是一个两个那么手动就能处理，如果成千上万的那么手动处理的方式就显得很吃力了。针对excel的处理可通过Python来实现，本文介绍如何使用Python来操作excel文件 环境介绍PC环境：WindowsPython版本：Python3.6IDE环境：PyCharm使用第三方库：openpyxl源码下载：http://03.xiaolinjun.top/0c4-0.zip 使用PyCharm建立Python工程在桌面新建文件夹：python_excel，双击打开PyCharm，点击Create New Project新建Python工程，选择工程目录文件夹为刚新建的python_excel，使用新的虚拟环境，选择Python解释器为Python3.6，如下图 工程建立完成后，在工程目录下新建文件：excel.py 使用PyCharm安装openpyxl库在PyCharm中安装openpyxl库。点击菜单栏File–&gt;Settings选择Project:python_excel下的Project Interpreter，然后点击右边的小加号，在弹出的窗口中搜索需要安装的库，然后点击安装 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from openpyxl import Workbookfrom openpyxl.chart import BarChart, Series, Referencedef excel_make(): wb = Workbook(write_only=True) ws = wb.create_sheet() rows = [ ('Number', 'Batch 1', 'Batch 2'), (2, 10, 30), (3, 40, 60), (4, 50, 70), (5, 20, 10), (6, 10, 40), (7, 50, 30), ] for row in rows: ws.append(row) chart1 = BarChart() chart1.type = "col" chart1.style = 10 chart1.title = "Bar Chart" chart1.y_axis.title = 'Test number' chart1.x_axis.title = 'Sample length (mm)' data = Reference(ws, min_col=2, min_row=1, max_row=7, max_col=3) cats = Reference(ws, min_col=1, min_row=2, max_row=7) chart1.add_data(data, titles_from_data=True) chart1.set_categories(cats) chart1.shape = 4 ws.add_chart(chart1, "A10") from copy import deepcopy chart2 = deepcopy(chart1) chart2.style = 11 chart2.type = "bar" chart2.title = "Horizontal Bar Chart" ws.add_chart(chart2, "G10") chart3 = deepcopy(chart1) chart3.type = "col" chart3.style = 12 chart3.grouping = "stacked" chart3.overlap = 100 chart3.title = 'Stacked Chart' ws.add_chart(chart3, "A27") chart4 = deepcopy(chart1) chart4.type = "bar" chart4.style = 13 chart4.grouping = "percentStacked" chart4.overlap = 100 chart4.title = 'Percent Stacked Chart' ws.add_chart(chart4, "G27") wb.save("bar.xlsx") if __name__ == '__main__': excel_make() 实现效果运行代码，可以看到生成一个bar.xlsx文件，打开后可以看到根据数据生成的四种不同图标 openpyxl使用参考：https://openpyxl.readthedocs.io/en/stable/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-安装第三方库]]></title>
    <url>%2F2018%2F09%2F28%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Python开发入门-安装第三方库 环境介绍PC环境：Windows10 64bitPython版本：Python3.6或Python2.7IDE环境：PyCharm pip安装大部分的库可以打开命令行，使用命令:1pip install xxx 如：安装flask库 下载压缩包安装在https://pypi.org/中找到要安装的库，把对应的压缩包下载下来。 解压下载的安装包，解压后通常会看见一个setup的文件，然后打开命令行，进入该文件夹，使用命令：1python setup.py install 下载.whl文件安装下载地址： https://www.lfd.uci.edu/~gohlke/pythonlibs/# 在下载地址把想要安装的库对应的.whl文件下载下来(如pykinsol库：pykinsol-0.1.2-cp36-cp36m-win_amd64，注意的是cp36对应python3.6版本，amd64对应Windows-64bit)，然后打开命令行，进入该文件所在的文件夹，使用命令：1pip install pykinsol-0.1.2-cp36-cp36m-win_amd64.whl]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python应用-爬取京东书籍信息]]></title>
    <url>%2F2018%2F09%2F25%2FPython%E5%BA%94%E7%94%A8-%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Python应用-爬取京东书籍信息 说到Python的应用，听到比较多的市爬虫，爬虫也是Python入门最好的练手项目。本文主要讲解xpath的用法，并使用xpath来分析和抓取爬取京东书籍的相关信息。关于书籍有一个基本的概念：国际标准书号（简称ISBN），每一本书出版都带有一个唯一的ISBN，本文也是通过ISBN来找到对应数据的信息 环境介绍PC环境：WindowsPython版本：Python3.6IDE环境：PyCharm使用第三方库：lxml、requests源码下载：http://03.xiaolinjun.top/0c5-0.zip 使用PyCharm建立Python工程在桌面新建文件夹：python_spiderJD，双击打开PyCharm，点击Create New Project新建Python工程，选择工程目录文件夹为刚新建的python_spiderJD，使用新的虚拟环境，选择Python解释器为Python3.6，如下图 工程建立完成后，在工程目录下新建文件：spiderJD.py 使用PyCharm安装相关第三方库在PyCharm中安装lxml和requests库。点击菜单栏File–&gt;Settings选择Project:python_spiderJD下的Project Interpreter，然后点击右边的小加号，在弹出的窗口中搜索需要安装的库，然后点击安装 安装好lxml和requests库后，可以看到该环境下多出了一下库（注：如提示安装失败，可能是由于pip的版本问题导致，可以将pip的版本降级为pip9以下版本或修改相关脚本文件） 代码实现爬取京东指定ISBN号书籍信息代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom lxml import html# 在京东商城通过ISBN来查找对应书籍信息def spider(isbn): # 获取URL url = 'https://search.jd.com/Search?keyword=&#123;0&#125;'.format(isbn) # 获取HTML文档，并将编码改为'utf-8' resp = requests.get(url) print(resp.encoding) resp.encoding = 'utf-8' html_doc = resp.text # 获取xpath对象 selector = html.fromstring(html_doc) # 找到列表的集合 ul_list = selector.xpath('//div[@id = "J_goodsList"]/ul/li') print(len(ul_list)) # 解析对应的内容、标题、价格、连接并打印 for li in ul_list: # 标题 title = li.xpath('div/div[@class = "p-name"]/a/@title') print(title[0]) # 购买连接 link = li.xpath('div/div[@class = "p-name"]/a/@href') print(link[0]) # 价格 price = li.xpath('div/div[@class="p-price"]/strong/i/text()') print(price[0]) # 店铺 store = li.xpath('div//a[@class="curr-shop"]/@title') print(store)if __name__ == '__main__': isbn = input('请输入ISBN') spider(isbn) 代码分析 首先导入requests库和lxml的html方法 定义函数实现获取京东网指定ISBN书籍信息 根据获取URL页面内容 把页面内容的编码方式改为utf-8 将页面内容转换为xpath对象 使用xpath解析页面内容，找出有用信息并打印 实现效果运行代码，输入ISBN号（以书籍 Python编程快速上手 让繁琐工作自动化 ISBN：9787115422699 为例），点击回车，如下 HTML页面分析技巧打开京东，搜索框中输入ISBN：9787115422699，点击搜索，然后按F12查看网页源码，点击左上角的小箭头工具，然后选择书籍的区域，这时会自动定位到源码中的位置]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发入门-开发环境搭建]]></title>
    <url>%2F2018%2F09%2F17%2FPython%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Python开发入门-开发环境搭建 人生苦短，我用Python。Python是一门非常容易入门的语言，同时也是一门高效的语言，在开始学习之前，需要搭建Python的开发环境。本文介绍Python3.6 + Python2.7的环境安装，同时也介绍相关的Python工具安装。Python主要有两个版本：Python3和Python2，这两个版本是不兼容的，Python2会在2020年停止维护，但是目前很多Python相关的库只支持Python2，而且有很多脚本工具也是使用Python2环境，所以在搭建Python的开发环境使用Python3和Python2兼容的方式安装 环境介绍PC环境：Windows10 64bitPython版本：Python3.6 + Python2.7IDE环境：PyCharm其他（可选）：Sublime Txt3 工具下载下面给出各工具的下载地址，根据不同的环境选择相对于的安装包进行安装： Python3.6 + Python2.7：https://www.python.org/downloads/ PyCharm：http://www.jetbrains.com/pycharm/download/#section=windows Sublime Txt3：https://www.sublimetext.com/3 工具安装Python3.6 + Python2.7安装下载Python3.6（目前Python3.6版本比较稳定）的对应安装包，双击安装（安装目录设为C:\Python36） 下载Python2.7的对应安装包，双击安装（安装目录设为C:\Python27） 安装完成后，需要添加环境变量，通过修改环境变量达到Python3和Python2切换使用。点击我的电脑–&gt;右键属性–&gt;高级系统设置–&gt;环境变量 在系统变量中新建一个环境变量，变量名：PY_HOME；值：C:\Python36（设置Python3为有效） 选择系统变量的Path，在他的值中添加%PY_HOME%\;%PY_HOME%\Scripts\; 点击确定完成设置，目前设置Python3为有效（如果要设置Python2有效，则把环境变量PY_HOME的值改为Python27即可），打开CMD命令行工具，输入python，则会进入python环境并打印Python3的版本号等信息 输入exit()退出python环境，输入pip -V，则会打印pip相关信息，python的环境到此安装完毕 PyCharm安装进入PyCharm官方，会有两个版本提供下载：专业版（收费）；社区版（免费开源），选择社区版下载安装即可，安装过程一路点击Next即可安装完成 Sublime Txt3安装Sublime Txt3是我个人非常喜欢的一款代码编辑工具，功能非常强大（几乎满足程序员的所有要求），下载安装也是很简单，到官网上下载，然后双击安装，一路Next即可。需要注意的是Sublime Txt3是收费的软件，但是网上有很多破解的教程，不过个人建议支持正版]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-Error:micro_ecc_lib_nrf52.lib:No such file or directory]]></title>
    <url>%2F2018%2F09%2F11%2FnRF52832-Error-micro-ecc-lib-nrf52-lib-No-such-file-or-directory%2F</url>
    <content type="text"><![CDATA[micro_ecc_lib_nrf52.lib错误解决 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 错误产生及原因在打开nRF5 SDK v15.1.0中的蓝牙外设例程（如心率例程：nRF5_SDK_15.1.0_a8c0c4d\examples\ble_peripheral\ble_app_hrs\pca10040\s132\arm5_no_packs）编译过程中发现一个错误123456linking....\_build\nrf52832_xxaa.axf: error: L6002U: Could not open file ..\..\..\..\..\..\external\micro-ecc\nrf52hf_keil\armgcc\micro_ecc_lib_nrf52.lib: No such file or directoryFinished: 0 information, 0 warning, 0 error and 1 fatal error messages.".\_build\nrf52832_xxaa.axf" - 1 Error(s), 0 Warning(s).Target not created.Build Time Elapsed: 00:00:33 从错误的提示来看，是在nRF5_SDK_15.1.0_a8c0c4d\external\micro-ecc\nrf52hf_keil\armgcc目录下缺少了micro_ecc_lib_nrf52.lib文件，打开该目录发现确实是缺少该文件 错误解决方法方法1直接copy一个micro_ecc_lib_nrf52.lib文件到该目录下，下载连接：micro_ecc_lib_nrf52.lib 方法2参考官方的解决方法，生成一个micro_ecc_lib_nrf52.lib文件 官方文档：http://infocenter.nordicsemi.com/index.jsp 解决位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Libraries &gt; Cryptography library - nrf_crypto &gt; nrf_crypto backend modules &gt; micro_ecc backend]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用-PPI使用]]></title>
    <url>%2F2018%2F09%2F09%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-PPI%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-PPI使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的pwm_library例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\ppi\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs PPI使用配置PPI配置步骤如下： 实例化PPI的通道 初始化PPI外设 为PPI通道申请内存，指定事件触发相关任务 使能PPI PPI相关参数说明： nRF52832的PPI通道由20个，在nrf52832_peripherals.h文件中定义 使用SoftDevice时，timer0不能使用 官方源码分析官方源码中PWM应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#define PPI_EXAMPLE_TIMERS_PHASE_SHIFT_DELAY (10) // 1s = 10 * 100ms (定时器1和定时器2的启动时间间隔)#define PPI_EXAMPLE_TIMER0_INTERVAL (100) // Timer0的定时时间 = 100ms#define PPI_EXAMPLE_TIMER1_INTERVAL (2000) // Timer1的定时时间 = 2s#define PPI_EXAMPLE_TIMER2_INTERVAL (2000) // Timer2的定时时间 = 2sstatic const nrf_drv_timer_t m_timer0 = NRF_DRV_TIMER_INSTANCE(0); //实例化Timer0static const nrf_drv_timer_t m_timer1 = NRF_DRV_TIMER_INSTANCE(1); //实例化Timer1static const nrf_drv_timer_t m_timer2 = NRF_DRV_TIMER_INSTANCE(2); //实例化Timer1static nrf_ppi_channel_t m_ppi_channel1; //PPI实例化channel1static nrf_ppi_channel_t m_ppi_channel2; //PPI实例化channel2static volatile uint32_t m_counter; //定义变量，技术Timer0的中断次数//Timer0的回调函数static void timer0_event_handler(nrf_timer_event_t event_type, void * p_context)&#123; ++m_counter;&#125;/* Timer1和Timer2的回调函数，由于Timer1和Timer2只用于PPI，所以没有使用 */static void empty_timer_handler(nrf_timer_event_t event_type, void * p_context)&#123;&#125;/** @brief PPI初始化函数.*/static void ppi_init(void)&#123; uint32_t err_code = NRF_SUCCESS; err_code = nrf_drv_ppi_init(); //PPI初始化 APP_ERROR_CHECK(err_code); //PPI的channel1初始化，通过Timer1的NRF_TIMER_EVENT_COMPARE0时间来使Timer0停止运行 err_code = nrf_drv_ppi_channel_alloc(&amp;m_ppi_channel1); //PPI的channel1申请内存 APP_ERROR_CHECK(err_code); //PPI的channel1分配任务，通过Timer1的NRF_TIMER_EVENT_COMPARE0时间来使Timer0停止运行 err_code = nrf_drv_ppi_channel_assign(m_ppi_channel1, nrf_drv_timer_event_address_get(&amp;m_timer1, NRF_TIMER_EVENT_COMPARE0), nrf_drv_timer_task_address_get(&amp;m_timer0, NRF_TIMER_TASK_STOP)); APP_ERROR_CHECK(err_code); //PPI的channel2初始化，通过Timer2的NRF_TIMER_EVENT_COMPARE0时间来使Timer0恢复运行 err_code = nrf_drv_ppi_channel_alloc(&amp;m_ppi_channel2); //PPI的channel2申请内存 APP_ERROR_CHECK(err_code); //PPI的channel2分配任务，通过Timer2的NRF_TIMER_EVENT_COMPARE0时间来使Timer0恢复运行 err_code = nrf_drv_ppi_channel_assign(m_ppi_channel2, nrf_drv_timer_event_address_get(&amp;m_timer2, NRF_TIMER_EVENT_COMPARE0), nrf_drv_timer_task_address_get(&amp;m_timer0, NRF_TIMER_TASK_START)); APP_ERROR_CHECK(err_code); // 使能PPI channels1、channels2 err_code = nrf_drv_ppi_channel_enable(m_ppi_channel1); APP_ERROR_CHECK(err_code); err_code = nrf_drv_ppi_channel_enable(m_ppi_channel2); APP_ERROR_CHECK(err_code);&#125;/** @brief Timer 0 初始化函数. * @details 实现功能：100ms触发一次NRF_TIMER_CC_CHANNEL0事件 */static void timer0_init(void)&#123; nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer0, &amp;timer_cfg, timer0_event_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer0, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer0, PPI_EXAMPLE_TIMER0_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true);&#125;/** @brief Timer 1 初始化函数. * @details 实现功能：2s触发一次NRF_TIMER_CC_CHANNEL0事件，通过PPI使Timer0停止运行 */static void timer1_init(void)&#123; nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer1, &amp;timer_cfg, empty_timer_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer1, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer1, PPI_EXAMPLE_TIMER1_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);&#125;/** @brief Timer 2 初始化函数. * @details 实现功能：2s触发一次NRF_TIMER_CC_CHANNEL0事件，通过PPI使Timer0恢复运行 */static void timer2_init(void)&#123; // Check TIMER2 configuration for details. nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; timer_cfg.frequency = NRF_TIMER_FREQ_31250Hz; ret_code_t err_code = nrf_drv_timer_init(&amp;m_timer2, &amp;timer_cfg, empty_timer_handler); APP_ERROR_CHECK(err_code); nrf_drv_timer_extended_compare(&amp;m_timer2, NRF_TIMER_CC_CHANNEL0, nrf_drv_timer_ms_to_ticks(&amp;m_timer2, PPI_EXAMPLE_TIMER2_INTERVAL), NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);&#125;/** * @brief Function for application main entry. */int main(void)&#123; uint32_t old_val = 0; uint32_t err_code; err_code = NRF_LOG_INIT(NULL); APP_ERROR_CHECK(err_code); NRF_LOG_DEFAULT_BACKENDS_INIT(); ppi_init(); //PPI初始化 timer0_init(); // Timer 0初始化 timer1_init(); // Timer 1初始化 timer2_init(); // Timer 2初始化 NRF_LOG_INFO("PPI example started."); //打印信息 nrf_drv_timer_enable(&amp;m_timer0); //使能Timer0 nrf_delay_us(5); //延迟5us，保障Timer0能在PPI触发前执行中断 nrf_drv_timer_enable(&amp;m_timer1); //使能Timer1 m_counter = (uint32_t)-PPI_EXAMPLE_TIMERS_PHASE_SHIFT_DELAY; while (m_counter != 0) //这里目的使等到10s，m_counter = -10，通过Timer0每100ms加一 &#123; // just wait &#125; nrf_drv_timer_enable(&amp;m_timer2); //使能Timer2，奇数秒Timer1触发停止Timer0，偶数秒Timer2触发运行Timer0 while (true) &#123; uint32_t counter = m_counter; if (old_val != counter) //Timer0使能时，每100ms打印一次counter值 &#123; old_val = counter; NRF_LOG_INFO("Current count: %u", counter); NRF_LOG_FLUSH(); &#125; &#125;&#125; 官方的例程实现过程以及效果： 实例化Timer0（100ms）、Timer1（2s）、Timer2（2s） 实例化PPI的channel1、channel2 实现Timer0回调函数，Timer1和Timer2回调函数（没有实际应用） 初始化PPI 配置PPI的channel1用于Timer2事件触发停止Timer0 配置PPI的channel1用于Timer2事件触发运行Timer0 使能PPI的channel1、channel2 初始化Timer Timer0每100ms触发NRF_TIMER_CC_CHANNEL0事件，m_counter变量加1 Timer1每2s触发NRF_TIMER_CC_CHANNEL0事件 Timer2每2s触发NRF_TIMER_CC_CHANNEL0事件 主函数实现奇数秒Timer1触发停止Timer0，偶数秒Timer2触发运行Timer0，Timer0使能时，每100ms打印一次counter值 实现效果：串口一秒打印十次counter值，然后停止一秒，依次循环串口配置： 波特率：115200 8位数据位 1位停止位 无奇偶校验 无流控 使用串口助手查看的效果如下： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; PPI Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; PPI 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:PWM使用]]></title>
    <url>%2F2018%2F09%2F09%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-PWM%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-PWM使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的pwm_library例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\pwm_library\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs PWM使用配置PWM配置步骤如下： 使用定时器实例化PWM 实现回调函数 PWM配置，可选择同时配置1个通道或两个通道以及其输出引脚，其他配置可使用独立函数进行配置 初始化PWM配置 使能PWM PWM相关参数说明： 定时器一共有5个：timer0~4，所以最多实例5个PWM 使用SoftDevice时，timer0不能使用 每个PWM实例最多可配置2个通道 官方源码分析官方源码中PWM应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243APP_PWM_INSTANCE(PWM1,1); // 使用定时器1实例化PWM，命名为PWM1static volatile bool ready_flag; // PWM指示标志位void pwm_ready_callback(uint32_t pwm_id) // PWM回调函数&#123; ready_flag = true;&#125;int main(void)&#123; ret_code_t err_code; /* 2-channel PWM配置, 频率200Hz, 输出在P17、P18引脚. */ app_pwm_config_t pwm1_cfg = APP_PWM_DEFAULT_CONFIG_2CH(5000L, BSP_LED_0, BSP_LED_1); /* 切换第二通道的极性. */ pwm1_cfg.pin_polarity[1] = APP_PWM_POLARITY_ACTIVE_HIGH; /* 初始化和使能 PWM. */ err_code = app_pwm_init(&amp;PWM1,&amp;pwm1_cfg,pwm_ready_callback); APP_ERROR_CHECK(err_code); app_pwm_enable(&amp;PWM1); uint32_t value; while (true) &#123; for (uint8_t i = 0; i &lt; 40; ++i) &#123; value = (i &lt; 20) ? (i * 5) : (100 - (i - 20) * 5); ready_flag = false; /* 设置通道0的占空比（1~100），并等到设置完成 */ while (app_pwm_channel_duty_set(&amp;PWM1, 0, value) == NRF_ERROR_BUSY); /* 等待回调函数处理，然后设置通道1的占空比 */ while (!ready_flag); APP_ERROR_CHECK(app_pwm_channel_duty_set(&amp;PWM1, 1, value)); nrf_delay_ms(25); //每25ms改变一次 &#125; &#125;&#125; 官方的例程实现过程以及效果： 通过定时器1来实例化PWM1 实现PWM1的回调函数 在主函数中配置PWM1的同个通道：周期200Hz，使用P17、P18引脚 单独配置通道1的输出极性搞（通道0输出极性默认低） 初始化和使能PWM1 每25ms设置一次通道0、1的占空比(两个通道占空比一样，极性相反) 实现效果：LED1（P17）由亮变暗和LED2（P18）由暗变亮 注：占空比的设置必须在PWM使能后 使用示波器检测P17、P18引脚的效果如下： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; PWM Library Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; SDK common libraries &gt; Pulse-width modulation (PWM) 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:Timer使用]]></title>
    <url>%2F2018%2F09%2F06%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-Timer%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nRF52832-Timer使用 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的timer例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\timer\pca10040\blank\arm5_no_packs目录下。注：pca10040代表nRF52832例程，blank代表基础应用工程，ARM-MDK5选择arm5_no_packs Timer使用配置Timer配置步骤如下： 实例化定时器，获取分配的实例ID 实现回调函数 定时器配置，一般使用默认配置，其他配置可使用独立函数进行配置 获取设定时间所需的ticks数 设置定时器通道的拓展比较模式 使能定时器实例 Timer相关参数说明： 定时器一共有5个：timer0~4，所以最多实例5个定时器 使用SoftDevice时，timer0不能使用 每个定时器最多拥有6个捕获比较通道NRF_TIMER_CC_CHANNEL0~5 官方源码分析官方源码中timer应用在main.c文件实现，本文根据个人理解作相应的注释，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const nrf_drv_timer_t TIMER_LED = NRF_DRV_TIMER_INSTANCE(0); //实例化timer0，获取分配ID：TIMER_LED/** * @brief 定时器事件处理函数（回调函数） */void timer_led_event_handler(nrf_timer_event_t event_type, void* p_context)&#123; static uint32_t i; uint32_t led_to_invert = ((i++) % LEDS_NUMBER); //LEDS_NUMBER = 4，该语句实现i由0~3依次循环 switch (event_type) //判断事件类型 &#123; case NRF_TIMER_EVENT_COMPARE0: //timer0的COMPARE0事件 bsp_board_led_invert(led_to_invert); //对LED[i]状态进行翻转 break; default: //其他事件不处理 //Do nothing. break; &#125;&#125;/** * @brief Function for main application entry. */int main(void)&#123; uint32_t time_ms = 500; //定时时间500ms uint32_t time_ticks; uint32_t err_code = NRF_SUCCESS; bsp_board_init(BSP_INIT_LEDS); //初始化LED1~LED4 nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG; //定时器配置，使用默认配置，默认参数在nrf_timer.h中定义 err_code = nrf_drv_timer_init(&amp;TIMER_LED, &amp;timer_cfg, timer_led_event_handler); //定时器初始化 APP_ERROR_CHECK(err_code); time_ticks = nrf_drv_timer_ms_to_ticks(&amp;TIMER_LED, time_ms); //获取500ms所需的ticks数 nrf_drv_timer_extended_compare( //配置timer0的捕获比较通道0的拓展比较模式，使能该通道中断 &amp;TIMER_LED, NRF_TIMER_CC_CHANNEL0, time_ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, true); nrf_drv_timer_enable(&amp;TIMER_LED); //使能定时器 while (1) &#123; __WFI(); //进入低功耗模式 &#125;&#125; 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; Timer Example timer相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; TIMER 代码烧录 擦除FLASH 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-基本外设使用:GPIO输出]]></title>
    <url>%2F2018%2F09%2F04%2FnRF52832-%E5%9F%BA%E6%9C%AC%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8-GPIO%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[nRF52832-GPIO输出 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） 使用官方的blinky例程，该位于nRF5_SDK_15.1.0_a8c0c4d\examples\peripheral\blinky\pca10040\s132\arm5_no_packs目录下。注：pca10040代表nRF52832例程，s132代表基于协议栈的工程，ARM-MDK5选择arm5_no_packs GPIO输出配置打开工程并打开main.c文件，可以看到mian函数内容如下：123456789101112131415int main(void)&#123; /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) &#123; for (int i = 0; i &lt; LEDS_NUMBER; i++) &#123; bsp_board_led_invert(i); nrf_delay_ms(500); &#125; &#125;&#125; 该例程是基于pca10040（nRF52832）开发板的LED例程，实现LED1~LED4依次闪烁的功能，下面根据LED的GPIO配置来配置P25和P26引脚输出高低电平，在main.c中添加自定义函数，如下：1234567891011121314/** * @函数名 Custom_Init * @功 能 用户自定义GPIO口初始化 * @参 数 无 * @返回值 无 */void Custom_Init(void)&#123; nrf_gpio_cfg_output(25); //初始化P25引脚，配置为输出模式 nrf_gpio_cfg_output(26); //初始化P26引脚，配置为输出模式 nrf_gpio_pin_write(25, 0); //P25引脚输出低电平 nrf_gpio_pin_write(26, 0); //P26引脚输出低电平&#125; 把该函数在main函数中初始化，然后在主函数循环中翻转P25和P26引脚状态，main函数如下：1234567891011121314151617int main(void)&#123; /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) &#123; for (int i = 0; i &lt; LEDS_NUMBER; i++) &#123; bsp_board_led_invert(i); nrf_gpio_pin_toggle(25); //翻转P25引脚状态 nrf_gpio_pin_toggle(26); //翻转P26引脚状态 nrf_delay_ms(500); &#125; &#125;&#125; 使用示波器检测P25和P26引脚状态，如下图： 资源参考官方文档：http://infocenter.nordicsemi.com/index.jsp 例程说明位于官方文档目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; Examples &gt; Hardware peripheral examples &gt; Blinky Example GPIO相关API函数说明位于官方目录：Software Development Kit &gt; nRF5 SDK &gt; nRF5 SDK v15.1.0 &gt; API Reference &gt; Peripheral drivers &gt; Peripheral drivers &gt; GPIO 代码烧录 擦除FLASH 烧写SoftDevice 烧写应用程序 具体操作参考：nRF52832-程序下载]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-程序下载]]></title>
    <url>%2F2018%2F08%2F29%2FnRF52832-%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[nRF52832程序下载 nRF52832程序下载可以分为两种： 基本外设使用例程，类似单片机的应用例程 基于SoftDevice的例程 环境介绍PC环境：WindowsIDE环境：ARM-MDK5SDK环境：nRF5 SDK v15.1.0硬件环境：nRF52832开发板（外设配置与官方pca10040开发板一致） nRF5283基本外设例程下载基本外设例程位于目录：examples\peripheral\，以该目录下的blinky例程为例，打开blinky\pca10040\blank\arm5_no_packs的MDK工程注：pca10040是官方的nRF52832开发板，IDE环境是ARM-MDK5对应arm5_no_packs中的工程 nRF52832的基本外设例程下载流程分两步： 擦除FLASH（只需要操作一次） 下载应用程序 具体实现如下： 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：基本外设使用的Programming Algorithm是nRF52xxx SoftDevice Erase和nRF52xxx_UICR） 点击菜单栏Flash–&gt;Erase擦除FLASH，点击编译程序没有错误，然后点击Flash–&gt;Download下载程序 SoftDevice例程下载基本外设例程位于目录：examples\peripheral\，以该目录下的blinky例程为例，打开blinky\pca10040\s132\arm5_no_packs的MDK工程注：pca10040是官方的nRF52832开发板，s132是针对nRF52832的SoftDevice，IDE环境是ARM-MDK5对应arm5_no_packs中的工程 nRF52832的基本外设例程下载流程分三步： 擦除FLASH（只需要操作一次） 下载SoftDevice 下载应用程序 在菜单栏切换目标工程为flash_s132_nrf52_6.1.0_softdevice，该工程是softdevice工程，不需要编译 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：SoftDevice使用的Programming Algorithm是nRF52xxx和nRF52xxx_UICR） 点击菜单栏Flash–&gt;Erase擦除FLASH，然后点击Flash–&gt;Download下载SoftDevice 在菜单栏切换目标工程为nrf52832_xxaa，该工程是基于softdevice的应用工程 打开工程的Options窗口，在Debug栏下选择对应的下载器协议（作者使用的是DAPLink），然后点击Setting 切换到Flash Download，勾选Reset and Run，添加Programming Algorithm，RAM for Algorithm下的大小改为0x2000，点击OK完成配置（注：SoftDevice使用的Programming Algorithm是nRF52xxx和nRF52xxx_UICR） 点击编译，然后点击Flash–&gt;Download下载应用程序 下载完成后重启一次，可以看到程序效果：LED1~LED4逐次亮–&gt;灭 基本应用程序与基于SoftDevice应用程序的区别基本应用程序与基于SoftDevice应用程序的区别在于ROM、RAM的分配不一样 基本应用程序的ROM、RAM的分配比较简单，直接是RAM大小和FLASH大小，如下图： 基于SoftDevice应用程序的FLASH和RAM分配比较复杂，因为SoftDevice就占用了一定的FLASH和RAM，应用程序根据剩下的FLASH和RAM空间进行分配定义，根据需求还需要添加Bootloader区域等。本文中的基于SoftDevice应用程序的FLASH和RAM分配如下图：]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nRF52832-开发环境]]></title>
    <url>%2F2018%2F08%2F29%2FnRF52832-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[开发环境搭建开发环境基于Windows10-64位平台 开发工具下载使用的软件和工具下载地址：nRF52832资源下载 软件开发包（SDK）下载：点击下载 ARM-MDK集成开发环境下载：点击下载 nRF5x的MDK支持包下载：点击下载 ARM.CMSIS.5.4.0.pack下载：点击下载 nRFgo Studio-Win64下载（nRF5x程序下载工具W10-64位）：点击下载 开发工具安装SDK是以压缩包形式打包的，里面包含各个外设的例程、协议栈、蓝牙通讯的Demo等等，下载后解压就可以直接使用 ARM-MDK开发环境安装： 下载并安装ARM-MDK，安装过程一路点击Next即可，建议保持默认路径 安装nRF5x的MDK支持包，双击安装，会自动识别ARM-MDK的安装路径 安装ARM.CMSIS.5.4.0.pack，双击安装，会自动识别ARM-MDK的安装路径 nRFgo Studio安装，该安装过程比较简单，一路保持默认，安装类型选择（Typical）,点击Next即可]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>nRF52832</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32F103-IAP设计与应用]]></title>
    <url>%2F2018%2F08%2F15%2FSTM32F103-IAP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[大部分MCU系统会具备下面三种编程方式： IAP（In Application Programming）在应用编程 ISP（In System Programing）在系统编程 ICP（In Circuit Programing）在电路编程 IAP是用户自己的程序在运行过程中对User Flash的部分区域进行重新烧写，产品发布后可以方便地通过预留的通信端口对产品中的固件程序进行更新升级。实现IAP有两个很重要的前提： 单片机程序能对自身内部User Flash进行擦写 单片机要有能够与外部进行通讯，如使用USART、IIC、SPI等 在实现IAP功能时，通常要设计两个程序：IAP程序、APP（应用）程序。IAP程序的功能就是作为Bootloader的角色，通过某种通讯协议（如USART）来接收APP程序并将其烧录到指定的User Flash中（注：IAP与APP程序在同一个FLASH中的不同地址上），然后跳转到APP中执行程序。ST官方提供STM32F10x的IAP相关资料，这里针对官方的STM32F10x的IAP资料进行应用，内容分为以下部分： STM32程序运行过程分析 STM32F10x IAP例程介绍 STM32F10x IAP例程测试 STM32程序运行过程分析想要设计STM32的IAP程序，必须先了解STM32的运行过程，下面以STM32F103的MCU为例介绍它的正常启动运行流程与加入IAP后的程序运行流程。 STM32正常启动流程 STM32上电后会从0x08000004处出去复位中断向量的地址，并跳转执行复位中断服务程序，如① 复位中断程序执行完后就会跳转到main函数中，如② main函数一般为死循环，当收到中断请求后STM32会强制把PC指向中断向量表，如③ 这时会查询中断向量表，根据中断源跳转到相应的中断服务程序中执行，如④ 执行完中断函数后再重新返回main函数中继续执行，如⑤ STM32加入IAP启动流程 STM32上电后会从0x08000004处出去复位中断向量的地址，并跳转执行复位中断服务程序，如① 执行完复位中断服务程序后进入到IAP的main函数中，将新的APP代码烧写到指定的User Flash中，然后跳转到APP中执行程序，如② 在APP中跳转到指定新的向量表，取出复位中断向量地址，并跳转执行新的复位中断服务程序，然后跳转至APP的main函数，如③ 这时FLASH中存在两个向量表，当有中断请求到来时，PC指针仍然会指向地址0x08000004中断向量表，如④ 查询中断向量表，根据中断来源跳转到新（APP）的中断服务程序中执行，如⑤ 执行完中断函数后再重新返回main函数中继续执行，如⑥注：灰色部分为APP代码 IAP例程介绍ST官方提供STM32F10x IAP资源包和一份应用笔记： STM32F10x IAP例程包，下载地址 :point_right: ST官网 STM32F10x IAP应用笔记，下载地址 :point_right: ST官网 IAP相关文件介绍把ST官方的STM32F10x IAP例程包下载并解压，在STM32F10x_AN2557_FW_V3.3.0\Project\IAP目录下有EWARM、HiTOP、MDK-ARM、RIDE、TrueSTUDIO的工程目录，以常用的MDK-ARM为例打开工程，根据目标MCU平台选择工程Target，如MCU平台为STM32F103C8T6（中容量产品），则工程Target选择STM3210B-EVAL，然后编译，IAP主要的代码在工程目录的User Groups下 User Groups下包含的IAP驱动相关的源文件和描述如下： main.c：初始化串口，然后从common.c文件中执行主菜单 common.c：内容显示函数和主菜单程序 ymodem.c和download.c：用于接收超级终端发送过来的数据（采用ymodem协议）并下载到STM32F10x内部RAM中 upload.c：把内部FLASH中的APP代码通过ymodem协议进行上传 整个IAP程序的运行框架如下图： IAP程序运行过程：判断用户按键是否按下（STM3210B-EVAL使用的是PB9，判断PB9是否为低电平），没有按下（PB9为高电平）就直接跳转到用户APP程序执行；如按下，初始化串口1，（连接到超级终端，超级终端）显示IAP菜单，菜单有：1-下载，2-上传，3-跳转（如检测到FLASH被写保护，就会有4-解除写保护）。 键盘输入1：提示下载APP程序文件，通过超级终端的ymodem协议把APP程序的二进制文件传输下载到指定的User FLASH中，如果出现错误则会在超级终端中显示出来，传输下载完成后会重新返回显示IAP主菜单 键盘输入2：提示把FLASH中APP程序通过ymodem协议在超级终端上传，如果出现错误则会在超级终端中显示出来 键盘输入3：跳转到APP程序运行 键盘输入4：解除FLASH写保护（该操作在系统检测到FLASH处于写保护才会显示到超级终端上） IAP例程使用概要IAP驱动程序也是需要下载到FLASH里运行的，IAP程序占用FLASH大小约为12KByte，在不同密度的产品占用FLASH的页数不一样（低、中密度为1KByte字节每页，超高、高密度为2KByte字节每页） 在低、中密度产品中，IAP程序占用FLASH的页0~页11 在超高、高密度产品中，IAP程序占用FLASH的页0~页5 IAP例程还需要一个支持ymodem协议的PC上位机（超级终端），使用STM32的串口连接PC，通过上位机来进行程序的上传和下载，这里使用的上位机软件是：SecureCRT8.3（安装和使用请参考百度） 打开STM32F10x_AN2557_FW_V3.3.0\Project\IAP目录下的MDK-ARM工程，选择Target为STM3210B-EVAL，编译并下载到测试目标板中（测试目标板MCU型号为STM32F103C8T6），通过串口连接测试目标板与PC，打开SecureCRT8.3建立基于串口通讯的快速连接（波特率：115200，数据位：8位，无奇偶校验，停止位：1位，无流控），然后把PB9引脚接低电平，复位测试目标板，可以看到上位机显示 注：程序检测到FLASH没有处于写保护状态时，不会显示FLASH擦除选项 下载APP例程文件在下载APP例程文件前，需要知道IAP程序中设置的APP程序FLASH地址，该地址位于工程的common.h文件下1#define ApplicationAddress 0x8003000 APP程序下载的FLASH起始地址为0x8003000。打开STM32F10x_AN2557_FW_V3.3.0\Project\IAP\binary_template目录下的MDK-ARM工程，选择Target为STM3210B-EVAL，该工程为官方提供的APP例程，打开工程的Options窗口，在Target栏下做如下修改（STM32F103C8T6的FLASH大小为64KB，APP例程的FLASH起始地址设为0x08003000，大小为：64KB-IAP使用的12KB = 52KB = 0xD000） 在User栏下，After Build/Rebuild选项下勾选Run #1，然后在对于的右侧填入D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe --bin -o ./STM3210B-EVAL/@L.bin ./STM3210B-EVAL/@L.axf，该语句的作用是在工程下的STM3210B-EVAL目录下生成STM3210B-EVAL.bin和STM3210B-EVAL.axf文件（如KEIL安装目录不一样，则需要修改D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe） 编译之后就会生成STM3210B-EVAL.bin，该APP例程的效果是4个LED闪烁，LED的IO口定义在stm3210b_eval.h文件下，可根据实际硬件LED连接来修改。 生成.bin文件后，回到上位机界面，然后键盘输入数字：1，此时上位机提示等待接收APP程序文件，在上位机菜单栏点击Transfer–&gt;Send Ymodem…，选择生成的APP程序文件STM3210B-EVAL.bin，然后点击Add，最后点击OK，发送成功后会显示发送的文件文件名和大小，然后再次返回IAP注菜单 注：发送超时会自动返回IAP主菜单 最后键盘输入数字：3，程序跳转到APP运行，可以看到LED闪烁。]]></content>
      <categories>
        <category>mcu编程类</category>
      </categories>
      <tags>
        <tag>STM32-IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAPLink设计与应用]]></title>
    <url>%2F2018%2F08%2F12%2FDAPLink%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[DAPLink是ARM官方的一款开源的调试仿真器，之前叫CMSIS-DAP。DAPLink的软件和硬件都在Github上开源： DAPLink软件地址： Github DAPLink硬件地址： Github DAPLink目前源码固件主要使用在LPC11U35以及MK20DX128VFM5的硬件上，并在Github上开源，成熟的DAPLink硬件方案有三个： DIPDAP（主芯片：LCP11U35FHI33/501） STDAP（主芯片：STM32F103CBT6） SWDAP（主芯片：LCP11U35FHI33/501） DAPLink可以对ARM Cortex内核（如 Cortex M3）进行仿真调试，并且提供源码和硬件，这样可以使用户可以轻松的集成一个仿真调试器到自己的项目上而无需担心版权问题。DAPLink不仅拥有仿真调试功能，同时它还具备虚拟串口和拖拽式下载功能（拖拽式下载只支持固件上对应的MCU） DAPLink介绍DAPLink功能介绍 MSC-拖拽式下载 CDC-日志打印、追踪和终端仿真的虚拟串口 HID-CMSIS-DAP兼容式调试接口 WEBUSB HID-CMSIS-DAP兼容式调试接口 MSC拖拽式下载通过复制或保存一个DAPLink支持的格式文件DAPLink的虚拟U盘中，完成后DAPLink设备就会重启。如果发生错误，错误的信息就会存放在FAIL.TXT中 DAPLink的MSC功能支持的文件格式如下： .bin .hex CDC-日志打印、追踪和终端仿真的虚拟串口CDC虚拟串口功能具备普通的串口IC功能，串行端口直接连接到目标MCU，允许双向通信。它还允许通过在串行端口上发送中断命令来重置目标。 串口通讯支持的波特率如下： 9600 14400 19200 28800 38400 56000 57600 115200注：大多数DAPLink还支持这里列出来之外的串口通讯波特率 HID-CMSIS-DAP兼容式调试接口CMSIS-DAP接口可以在任何支持CMSISI-DAP协议的IDE中进行调试，其中包括： pyOCD uVision IAR WEBUSB HID-CMSIS-DAP兼容式调试接口WEBUSB HID-CMSIS-DAP是用于网页上进行调试的接口。 DAPLink官方介绍 Arm Mbed DAPLink是一个开源软件项目，它能够在Arm Cortex架构上的CPU运行编程和调试应用程序。DAPLink是作为应用MCU的SWD或JTAG接口的辅助型MCU，通常称之为接口固件。这种配置几乎在所有的开发板上都可以看到，DAPLink枚举为一个USB复合设备，为开发者的计算机和CPU调试访问端口之间建立了一个桥梁。DAPLink能让开发者具有： MSC-拖拽式编程FLASH闪存 CDC-日志打印、追踪和终端仿真的虚拟串口 HID-CMSIS-DAP兼容式调试接口 WEBUSB HID-CMSIS-DAP兼容式调试接口 更多的功能正在规划兵渐渐展现出来。DAPLink项目不断地在Arm、它的合作伙伴、众多的硬件供应商和世界各地的开源社区的大力开发之下，取代了CMSIS-DAP接口固件项目，你可以尽情使用和贡献。Enjoy! 更多可用的细节信息可查看DAPLink用户指南DAPLink用户指南 兼容性DAPLink接口固件已经运行在许多基于ARM微控制器的硬件接口电路（HICs），它们可用作独立的（调试器）板子或作为开发工具的一部分。一些已知的IO兼容品牌的电路如下： NXP OpenSDA based on K20, K22 and KL26 NXP LPC-Link2 based on LPC11U35 or LPC4322 Segger J-Link OB based on Atmel SAM3U Maxim Epsilon based on MAX32550 - coming soon 版本DAPLink官方的Github仓库创建了许多板级构建（板 = HIC + 目标组合）。季度版本将包含新的特性和修复BUG，一旦根据报告、验证并修复BUG，就会发布独立的修复BUG后的版本无论是季度版本还是修复Bug版本，都会导致生成号递增。许多开发工具包和产品与DaPink接口固件一起运行，或者能够运行DaPink固件。当前发布版本和更新DaPink界面固件的指令是在DaPink发布站点上托管的。发行说明和以前发布版本可以在GITHUB发行版中找到 DAPLink开发环境搭建Windows工具安装本章介绍在Windows下的DAPLink开发环境搭建。安装的工具列表如下，如果有些工具已经安装好可以跳过（注意：软件安装包尽量选择最新版，选择适合自己电脑的32/64位安装包） Python2，版本2.7.9以上，并添加环境变量：下载地址 Git，并添加环境变量：下载地址 Keil MDK-ARM ：下载地址注意：软件安装时尽量使用默认路径 获取源码&amp;生成MDK工程将需要的的工具安装完成后，点击鼠标右键，选择Git Bash Here打开Git命令行界面，按以下步骤输入命令进行操作 下载DAPlink源码到本地 1$ git clone https://github.com/mbedmicro/DAPLink 切换到DAPLink目录下 1$ cd DAPLink 安装虚拟环境 1$ pip install virtualenv 进入拟环境 1$ virtualenv venv 启动虚拟环境下的脚本 1$ venv/Scripts/activate 安装requirements.txt表中的工具 1$ pip install -r requirements.txt 生成MDK工程 1$ progen generate -t uvision 关闭Git命令行界面，在DAPlink目录下有个projectfiles文件夹，里面就是生成的MDK工程，可使用MDK-ARM工具打开 编译源码 打开DAPLink\projectfiles\uvision目录下的工程，如lpc11u35_lpc812xpresso_if工程，如弹出Using an MDK Version 4 Project窗口，选择Migrate to Device Pack 此时会打开Pack Install窗口并自动下载安装相应的固件包，等待安装完成并关闭 编译工程，在lpc11u35_lpc812xpresso_if\build目录会生成.bin和.hex文件 其他问题&amp;解决方法 编译源码的第1步中提示的问题是因为MDK-ARM版本问题引起，可安装对应MDK-ARM的MDK4兼容包解决 ：下载地址 编译源码的第2步中如果提示找不到LPC11U35型号，可在Pack Install窗口搜索LPC1100并安装LPC1100 Series固件包；或者在KEIL官网下载安装LPC1100 Series固件包：下载地址 工程目录projectfiles\uvision\下的文件，以_if结尾的工程是对应工程的应用程序；_bl结尾的是对应工程的Bootloader应用程序，LPC11U35自带Bootloader程序 DAPlink硬件官方DAPLink硬件官方DAPLink硬件是开源的，开源地址 ： Github 目前成熟的DAPLink硬件方案有三个，分别是位于mbed-HDK\Production Design Projects\ARM-mbed\DAPLink目录下的： DIPDAP STDAP SWDAP DIPDAP DIPDAP是基于NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 通过DIPDAP提供的硬件材料，用户可以轻松的制作一个，如果嫌麻烦可以在网上购买成品， 购买地址 STDAPSTDAP是基于ST STM32F103CBT6为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 需要注意的是，目前官方的DAPLink固件中并没有支持STDAP的固件 SWDAP DIPDAP是基于NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载等功能，DIAPDAP硬件包括以下内容： Eagle原理图和板子文件（注：Eagle是PCB Layout软件） PDF版原理图和板子副本文件 Gerber生产文件 BOM（材料清单） eBOM（一份网上购物清单，方便购买！） 通过DIPDAP提供的硬件材料，用户可以轻松的制作一个，如果嫌麻烦可以在网上购买成品， 购买地址 技新DAPLink硬件 技新DAPLink参考官方DIPDAP硬件设计，以NXP LPC11U35为核心，支持CMSIS-DAP接口、拖拽式下载、虚拟串口等功能。技新DAPLink设计采用LCEDA，元器件在立创商城平台采购，PCB在嘉立创平台生产。技新DAPLink也是开源的，包括： Gerber文件，可直接打样生产 PCB文件、原理图文件 BOM（元器件采购清单） 技新DAPLink的设计主要是为了解决以下问题： 官方DAPLink硬件在国内购买比较麻烦 官方DAPLink硬件的BOM中的元器件国内购买比较麻烦 提供一个官方DAPLink设计参考 提供一个官方DAPLink方案验证 作为小册的硬件实验使用 技新DAPLink硬件地址： DAPLink_JX技新DAPLink购买地址： 淘宝技新DAPLink开源地址： 码云 DAPLink应用DAPLink固件更新DAPLink固件由两个部分组成 以xxx_bl结尾的.bin文件（Bootloader） 以xxx_if结尾的.bin文件（应用程序） NXP的LPC11U35是自带Bootloader，原装的LPC11U35芯片首次上电时就会自动进入Bootloader，虚拟出一个U盘设备，然后将以应用程序拖进去即可完成烧录，之后就会自动运行应用程序 技新DAPLink固件更新 按住K1（或短接nRST和GND）插入电脑就会识别出一个CRP DISABLDU盘设备，里面有一个firmware.bin文件，将其删除 把第二章的编译产生的DAPLink固件lpc11u35_lpc812xpresso_if_crc.bin（固件位于DAPLink\projectfiles\uvision\lpc11u35_lpc812xpresso_if\build目录下）拖（复制）到U盘中 将DAPLink重新插拔一次（不需要按住K1或短接nRST和GND），就会看到一个DAPLINKU盘设备，固件更新完毕 固件更新后，DAPLINK内有DETALLS.TXT和MBED.HTM两个文件，MBED.HTM是一个网页，DETALLS.TXT是该DAPLink固件的相关信息：1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 0Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 0URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T DAPLink插入电脑后会识别出如下设备（如果有部分设备无法识别请检查系统驱动是否有问题）： MSD–USB大容量存储设备（拖拽式下载） CDC–mbed Serial Port（虚拟串口） HID–符合HID标准的供应商定义设备/USB输入设备（CMSIS-DAP接口） WebUSB：CMSIS-DAP或USB_DFU注：W7和W8系统的CDC驱动需要手动安装， 驱动地址 其他DAPLink固件更新LPC11U35本身自带Bootloader，所以只需要Bootloader的MMSD接口把固件烧录进去即可，对于本身没有自带Bootloader功能的，需要先往里先烧录Bootloader。DAPLink的固件源码编译生成的工程，对于LPC11U35之外没有Bootloader功能的DAPLink硬件提供了Bootloader固件，如DAPLink\projectfiles\uvision目录下的k20dx_bl工程就是k20dx的Bootloader DAPLink在ARM-MDK中的使用DAPLink的CMSIS-DAP接口是用于ARM Cortex内核MCU调试仿真的，只要IDE支持CMSIS-DAP协议接口即可使用DAPLink，这里以ARM-MDK为例，其他的IDE也类似使用，调试仿真使用的是DAPLink的CMSIS-DAP接口功能 DAPLink作为仿真器连接目标设备，如STM32F103C8T6最小系统板 打开STM32F103C8T6的ARM-MDK例程 打开Options for Target选项，在Debug栏下的Use选项选择CMSIS-DAP Debugger 点击Settings，Debug栏设置如下图，点击OK完成配置，之后即可编译下载/调试 DAPLink的MSD命令使用DAPLink允许通过MSD接口来给它一些简单的命令。复制一个指定命名的文件通过MSD接口到DAPLink，可以使DAPLink执行一个动作或一个永久有效配置，文件的内容可以被忽略（可以发送一个空文件） MSD的命令只有在下面状态下才有效 插入DAPLink，再按住K1，然后把相应的.act或.cfg文件复制到MSD接口 在打automation-allowed模式下，把相应的.act或.cfg文件复制到MSD接口 MSD命令有两种 .act文件，触发DAPLink一个Action（动作） .cfg文件，配置DAPLink一个Configuration（设置） Action命令start_bl.act 该文件将强制进入Bootloader，相当于拔下DAPLink，按住K1再插上。如果DAPlink已经处于Bootloader，则该命令无效 start_if.act 该文件将强制DAPLink重新进入DAPLink接口模式。它相当于拔下USB电缆，并将其插入。如果已经处于DAPLink接口模式，则此命令无效 assert.act 该文件可以用来测试DAPLink的assert实用程序。当您将该文件复制到DAPLink MSD驱动器时，DAPLink将生成对util_assert()方法的调用。assert调用导致DAPLink MSD驱动器重新加载一个附加文件ASSERT.TXT，出现在驱动器的根部。这个文件详细说明了断言失败发生的地方(源文件，行号) refresh.act 该文件强制重新加载DAPLink MSD驱动器 erase.act 该文件触发对目标FLASH的擦除 Configuration命令auto_rst.cfg 该文件用于配置自动复位模式，默认情况下自动复位是禁止的 hard_rst.cfg 该文件用于关闭自动复位模式，默认情况下自动复位是禁止的 auto_on.cfg 该文件用于打开automation-allowed模式，再该模式下可以出发DAPLink的MSD命令，而不需要按住K1案件。此外，Bootloader更新只允许再该模式下运行 auto_off.cfg 该文件用于关闭automation-allowed模式，automation-allowed模式默认是关闭的 ovfl_on.cfg 该文件用于打开串口溢出报告。再串口通讯过程中，如果主机PC没有以足够快的速度从DAPLink读取数据，并且发生溢出，则文本&lt;DAPLink: overflow &gt;将出现在串行数据中。串行溢出报告默认关闭 ovfl_off.cfg 该文件用于关闭串口溢出报告 MSD命令使用 使能automation-allowed模式。新建文本文档并重命名为auto_on.cfg，插入DAPLink并按按K1，然后把auto_on.cfg文件拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Remount count: 1 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 1URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 触发一个Action。新建文本文档并重命名为refresh.act，将该文档拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Remount count: 2 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 0Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 2URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 配置一个Configuration。新建文本文档并重命名为refresh.act，将该文档拷贝进DAPLink的MSD接口（虚拟U盘），这时DAPLink的MSD会重启，在根目录的DETAILS.TXT文件中Automation allowed: 1; Overflow detection: 1; Remount count: 3 1234567891011121314# DAPLink Firmware - see https://mbed.com/daplinkUnique ID: 105000001781cdaa00000000000000000000000097969902HIC ID: 97969902Auto Reset: 0Automation allowed: 1Overflow detection: 1Daplink Mode: InterfaceInterface Version: 0247Git SHA: 7574bed494828d1da9a170d4f2727bba28362eafLocal Mods: 0USB Interfaces: MSD, CDC, HID, WebUSBInterface CRC: 0x7ba4edb8Remount count: 3URL: https://mbed.org/device/?code=105000001781cdaa00000000000000000000000097969902?version=0247?target_id=@T 注：其他MSD命令使用也如上配置 DAPLink其他功能介绍CDC虚拟串口DAPLink带有虚拟串口功能，可用于与目标设备进行串口通讯，使用方法与其他UDB转TTL的模块一样，支持的比特率有：123456789600144001920028800384005600057600115200 注：大多数DAPLink还支持这里列出来之外的串口通讯波特率 MSC拖拽式下载功能DAPLink带有拖拽式下载功能，但是该功能通常只针对独立的目标设备，如固件lpc11u35_lpc812xpresso_if_crc.bin的拖拽式下载是针对lpc812xpresso目标的，如果想支持其他的目标就需要对DAPLink固件进行修改移植，参考文档 其他功能DAPLink还提供了非常多的功能和应用，如自动化测试、添加一个新板支持、添加一个新设备、移植到新的硬件电路等，其中的操作都有独立的文档讲解，本章介绍的固件更新和DAPLink的MSD命令使用也只是其中一部分功能，具体可参考： DAPLink官方文档]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>DAPLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo:搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2FHexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Create Hexo需要环境环境安装是只需一直点Next即可 PC:Windows10 64-bit Git:Download 2.18.0 for Windows Node.js:Windows Installer(.msi)64-bit 安装Hexo安装好Git和Node.js环境后，打开Git Bash，然后输入如下命令安装Hexo1npm install hexo-cli -g 输入如下命令查看是否安装成功1hexo -v 出现下面内容，即为安装成功12345678910111213141516hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.6.0v8: 6.7.288.46-node.13uv: 1.21.0zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.32.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 接下来在G盘新建blog文件夹（可根据个人而定），用于作为hexo博客目录。现在在Git Bash进入到blog文件夹，然后在里面初始化为hexo博客目录123cd g:bloghexo init 初始化成功信息如下1234added 397 packages from 485 contributors and audited 2021 packages in 51.695sfound 0 vulnerabilitiesINFO Start blogging with Hexo! 然后安装依赖包1npm install 出现下面信息即安装完成12audited 2021 packages in 2.965sfound 0 vulnerabilities 下面输入命令来生成静态页面1hexo generate 输入启动服务命令1hexo server 可以看到一下信息12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 现在打开浏览器访问http://localhost:4000/即可看到，在Git Bash按Crl+c就会关闭网站。 note:如果出现防火墙提示，放行就可以了 部署网站到GithubGithub仓库创建 新建一个仓库，命名方式：userName+’github.io’ 点击Create Repository后，选择Setting进入设置 在Github Pages下点击Choose a theme选择一个主题 此时返回仓库再点击Setting既可以查看到github分配的域名 在git配置githun的邮箱与用户名查看git配置信息1git config --list 配置github的邮箱1git config --global user.email &quot;输入你的邮箱&quot; 配置github的用户名1git config --global user.name &quot;输入你的用户名&quot; 重新输入查看git的配置信息会发现多了邮箱和用户名的配置 将本地的博客发布到github上回到Git Bash，修改博客根目录的_config.yml文件，修改如下1234deploy: type: git repository: https://github.com/LGG001/LGG001.github.io.git branch: master 然后安装部署插件1npm install hexo-deployer-git —save 最后部署到github上1hexo d 补充：生成SSH Key在Git Bash中输入命令来生产SSH密钥1ssh-keygen -t rsa -C &quot;1058901869@qq.com&quot; 接着会要求输入密语字符串，直接回车跳过即可。然后会让输入2次口令，这里也直接输入两次回车跳过（使用3次回车就会生产一份公钥id_rsa.pub和一份密钥id_rsa，这两份密钥位于根目录下的.ssh目录下） 公钥需要在Github上的Settings--&gt;SSH and GPG keys上配置，把生成好的公钥id_rsa.pub复制到key输入框中，然后为key起一个title来区分每个key。生成后Github会发一封邮件提醒 接下来回到博客根目录1cd g:blogs 修改_config.yml文件1vim _config.yml 修改deploy部分，如下1234deploy: type: git repository: git@github.com:LGG001/LGG001.github.io.git branch: master 最后重新输入如下命令来重新发布到Github上123hexo cleanhexo ghexo d 输入网址https://lgg001.github.io/即可访问博客了 发表文章新建文章在博客的目录文件夹下进入Git Bash，然后输入hexo new “博文名字”，如hexo new “Hexo:搭建个人博客” 在blogs\source_post目录下就会再到”博文名字”.md的文件，该文件的内容是使用MarkDown格式的，使用MarkDown编辑器编辑。个人推荐：MarkDownPad2 添加分类在blogs\scaffolds目录下，修改post.md文件1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags: 观察成的”Hexo:搭建个人博客”文章内容123456---title: &apos;Hexo:搭建个人博客&apos; #文章页面显示的名称categories: #文章分类目录date: 2018-07-20 23:23:06 #文章生成时间tags: #文章标签--- 在文章下面就可以写自己的内容了。 如果想给文章添加图片的效果，在文章里面的头上添加photos选项即可123456789---layout: phototitle: &apos;Hexo:搭建个人博客&apos; #文章页面显示的名称categories: #文章分类目录date: 2018-07-20 23:23:06 #文章生成时间tags: #文章标签photos: - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg--- 使用描述、摘要描述和摘要的使用如下123456789title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述以上是摘要&lt;!--more--&gt;以下是余下全文 使用图片在Git Bash输入1npm install hexo-asset-image --save 重新创建一个博客名字，然后发现Hexo\source_posts下多了一个与博客名字相同的空文件夹,然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可. 安装主题（Next）安装Next主题关于Next的详细内容可以参考Next官方文档 安装Next主题只需要一条命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，打开博客的配置文件_config.yml文件，修改主题为next1theme: next 然后输入hexo s --debug在本地查看预览效果 打开themes\next目录，编辑主题的配置文件_config.yml 重新发布主题到Github上123hexo cleanhexo ghexo d]]></content>
  </entry>
</search>
